
////////////////////////////////////////////////
//  Transcribe the wall polygons with the associated
//  numbers from one wed file to another, adjusting
//  their vertices and bounding boxes by delta.
//
//  Polygons must be listed sequentially.
////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION transcribe_polygons
   INT_VAR delta_x=0
           delta_y=0
           stretch_numerator=1
           stretch_denominator=1
           stretch_base_x=0
           stretch_base_y=0
   STR_VAR from_area=""                   
           to_area=""
           polygons=""
BEGIN
   OUTER_SPRINT polygon_data ""
   OUTER_SPRINT vertex_data ""
   OUTER_SET vertex_count=0
   OUTER_SET polygon_count=0
   // get the data
   COPY_EXISTING "%from_area%.wed" "override"
        READ_LONG 0x14 sec_header_off
        READ_LONG sec_header_off + 0x4 polygon_off
        READ_LONG sec_header_off + 0x8 vertex_off
        WHILE "%polygons%" STRING_COMPARE_CASE "" BEGIN
           LPF return_first_entry STR_VAR list="%polygons%" RET entry polygons=list END
           // get some data
           READ_LONG (polygon_off + 0x12 * entry) this_polygon_ind
           READ_SHORT (polygon_off + 0x12 * entry +0x4) this_polygon_count
           // get the polygon itself
           READ_ASCII (polygon_off + 0x12 * entry) this_polygon (0x12)
           // adjust it
           INNER_PATCH_SAVE this_polygon "%this_polygon%" BEGIN
               WRITE_LONG 0x0 vertex_count
               READ_SHORT 0xa x
               LPF stretch_point INT_VAR x x_0=stretch_base_x numerator=stretch_numerator denominator=stretch_denominator RET x END
               WRITE_SHORT 0xa (x + delta_x)
               READ_SHORT 0xc x
               LPF stretch_point INT_VAR x x_0=stretch_base_x numerator=stretch_numerator denominator=stretch_denominator RET x END
               WRITE_SHORT 0xc (x + delta_x)
               READ_SHORT 0xe y
               LPF stretch_point INT_VAR y y_0=stretch_base_y numerator=stretch_numerator denominator=stretch_denominator RET y END
               WRITE_SHORT 0xe (y + delta_y)
               READ_SHORT 0x10 y
               LPF stretch_point INT_VAR y y_0=stretch_base_y numerator=stretch_numerator denominator=stretch_denominator RET y END
               WRITE_SHORT 0x10 (y + delta_y)
           END
           // get the vertices
           READ_ASCII (vertex_off + 0x4*this_polygon_ind) these_vertices (0x4*this_polygon_count)
           // adjust them

           INNER_PATCH_SAVE these_vertices "%these_vertices%" BEGIN
              FOR (i=0;i<this_polygon_count;i+=1) BEGIN
                 READ_SHORT 4*i x
                 READ_SHORT (4*i + 2) y
                 LPF stretch_point INT_VAR x y x_0=stretch_base_x y_0=stretch_base_y numerator=stretch_numerator denominator=stretch_denominator RET x y END
                 WRITE_SHORT 4*i (x + delta_x)
                 WRITE_SHORT (4*i + 2) (y + delta_y)
              END
           END

           // add to the pile
           SPRINT polygon_data "%polygon_data%"^"%this_polygon%"
           SPRINT vertex_data "%vertex_data%"^"%these_vertices%"
           polygon_count +=1
           vertex_count +=this_polygon_count
        END
   BUT_ONLY
   // patch the data in
   
   COPY_EXISTING "%to_area%.wed" override
        READ_LONG 0x14 sec_header_off
        READ_LONG 0xc door_num
        READ_LONG 0x18 door_off
        READ_LONG sec_header_off polygon_num
        READ_LONG sec_header_off + 0x4 polygon_off
        READ_LONG sec_header_off + 0x8 vertex_off
        READ_LONG sec_header_off + 0x10 polygon_index_off
        // start with the vertices
        PATCH_IF polygon_num>0 BEGIN
           READ_LONG (polygon_off + 0x12 * (polygon_num - 1) ) last_wall_ind
           READ_LONG (polygon_off + 0x12 * (polygon_num - 1) +4 ) last_wall_count
           vertex_insert=last_wall_ind + last_wall_count
        END ELSE BEGIN
           vertex_insert=0
        END
        INSERT_BYTES (vertex_off + 0x4 * vertex_insert) (4*vertex_count)
        WRITE_ASCIIE (vertex_off + 0x4 * vertex_insert) "%vertex_data%"
        // now insert the wall polygons
        new_polygon_num=polygon_num + polygon_count
        WRITE_LONG sec_header_off new_polygon_num
        INSERT_BYTES (polygon_off + 0x12 * polygon_num) (0x12*polygon_count)
        WRITE_ASCIIE (polygon_off + 0x12 * polygon_num) "%polygon_data%"
        // go through the new polygons and update their indices
        FOR (i=polygon_num;i<new_polygon_num;i+=1) BEGIN
           WRITE_LONG (polygon_off + 0x12*i) ( ( LONG_AT (polygon_off + 0x12*i) ) + vertex_insert )
        END
        // update vertex offset and wallgroup index offset
        WRITE_LONG sec_header_off + 0x8 (vertex_off + 0x12*polygon_count)
        WRITE_LONG sec_header_off + 0x10 (polygon_index_off + 0x12*polygon_count)

        // update vertices and offsets for doors
        FOR (i=0;i<door_num;i+=1) BEGIN
           // open polygons
           READ_LONG (0x12 + door_off + i *0x1a) door_poly_off
           door_poly_off += 0x12*polygon_count
           WRITE_LONG (0x12 + door_off + i *0x1a) door_poly_off
           READ_SHORT (0xe + door_off + i *0x1a) door_poly_count
           FOR (j=0;j<door_poly_count;j+=1) BEGIN
              READ_LONG (door_poly_off + 0x12*j) ind
              ind += vertex_count
              WRITE_LONG (door_poly_off + 0x12*j) ind
           END
           // closed polygons
           READ_LONG (0x16 + door_off + i *0x1a) door_poly_off
           door_poly_off += 0x12*polygon_count
           WRITE_LONG (0x16 + door_off + i *0x1a) door_poly_off
           READ_SHORT (0x10 + door_off + i *0x1a) door_poly_count
           FOR (j=0;j<door_poly_count;j+=1) BEGIN
              READ_LONG (door_poly_off + 0x12*j) ind
              ind += vertex_count
              WRITE_LONG (door_poly_off + 0x12*j) ind
           END

        END

        LPF rebuild_wall_groups END

   BUT_ONLY
END


////////////////////////////////////////////////
//  Delete wall polygons by number
////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION delete_polygons
    STR_VAR area=""
            polygons=""
BEGIN
   COPY_EXISTING "%area%.wed" override
    // read in polygons
    WHILE "%polygons%" STRING_COMPARE "" BEGIN
       CLEAR_ARRAY deleted_polygons
       LPF return_first_entry STR_VAR list="%polygons%" RET entry polygons=list END
       SPRINT $deleted_polygons("%entry%") ""
    END
    // initialise
    vertex_delete_count=0
    polygon_delete_count=0
    // get initial data
    READ_LONG 0xc door_count
    READ_LONG 0x18 door_off
    READ_LONG 0x14 sec_header_off
    READ_LONG sec_header_off polygon_count
    READ_LONG sec_header_off + 4 polygon_off
    READ_LONG sec_header_off + 8 vertex_off
    READ_LONG sec_header_off + 0x10 poly_ind_off
    // go through polygons
    FOR (ind=0;ind<polygon_count;ind +=1) BEGIN
        polygon_off_here=polygon_off + (ind - polygon_delete_count) * 0x12
        READ_LONG polygon_off_here start_ind
        start_ind -= vertex_delete_count
        // delete indices if appropriate, otherwise adjust indices
        PATCH_IF VARIABLE_IS_SET $deleted_polygons("%ind%") BEGIN
           WRITE_LONG polygon_off_here start_ind
           READ_LONG polygon_off_here + 4 vert_count
           WRITE_LONG polygon_off_here +4 0
           vertex_delete_count += vert_count
           DELETE_BYTES (vertex_off - 0x12* polygon_delete_count + start_ind *4) (vert_count *4)

           DELETE_BYTES polygon_off_here 0x12
           polygon_delete_count +=1

        END ELSE BEGIN
        WRITE_LONG polygon_off_here start_ind
        END
    END
    // adjust offsets and vertex indices for doors
    FOR (ind=0;ind<door_count;ind +=1) BEGIN
           door_off_here = door_off + ind*0x1a
           READ_LONG (0x12 + door_off_here) poly_open_off
           poly_open_off -= 0x12*polygon_delete_count
           WRITE_LONG (0x12 + door_off_here) poly_open_off
           READ_LONG (0x16 + door_off_here) poly_closed_off
           poly_closed_off -= 0x12*polygon_delete_count
           WRITE_LONG (0x16 + door_off_here) poly_closed_off
           READ_SHORT (0xe + door_off_here) poly_open_count
           READ_SHORT (0x10 + door_off_here) poly_closed_count
           FOR (ind2=0;ind2<poly_open_count;ind2+=1) BEGIN
              READ_LONG (poly_open_off + 0x12*ind2) ind_here
              ind_here -=vertex_delete_count
              WRITE_LONG (poly_open_off + 0x12*ind2) ind_here
           END
           FOR (ind2=0;ind2<poly_closed_count;ind2+=1) BEGIN
              READ_LONG (poly_closed_off + 0x12*ind2) ind_here
              ind_here -=vertex_delete_count
              WRITE_LONG (poly_closed_off + 0x12*ind2) ind_here
           END
    END
    // adjust number of polygons
    polygon_count -=polygon_delete_count
    WRITE_LONG sec_header_off polygon_count
    // adjust offset for polygon indices
    READ_LONG sec_header_off + 0x10 poly_ind_off
    WRITE_LONG sec_header_off + 0x10 ( poly_ind_off -0x12 * polygon_delete_count)
    // adjust offset for vertices
    WRITE_LONG sec_header_off + 8 (vertex_off - 0x12 * polygon_delete_count)
    LPF rebuild_wall_groups END
END

////////////////////////////////////////////////
///  Stretch a point away from a reference point
////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION stretch_point
   INT_VAR x=0
           y=0
           x_0=0
           y_0=0
           numerator=1
           denominator=1
   RET     x y
BEGIN
   PATCH_IF !(numerator=1 && denominator=1) BEGIN
      delta_x = x - x_0
      delta_y = y - y_0
      delta_x = (delta_x * numerator) / denominator
      delta_y = (delta_y * numerator) / denominator
      x = x_0 + delta_x
      y = y_0 + delta_y
   END
   // PATCH_PRINT "%x% %y%"
END


//////////////////////////////////////////
/// Copy an area, cropping it to the desired
/// size (in tiles). 
///
/// After doing it, you might want to rebuild
/// the TIS in NI, as it's quite inefficiently
/// stored in this algorithm
///
/// *Mostly* polygons need to be ordered with the
/// lowest point first (as per IESDP). But this is
/// NOT always correct and I can't work out the true
/// algorithm. 
///
/// EE only
////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION crop_area
    INT_VAR x=0 xlen=0 y=0 ylen=0
    STR_VAR area_old=""
            area_new=""
BEGIN
    // identify the TIS and WED files (I assume standard notation, except possibly an ARE with a nonstandard WED)
    // and copy everything over
    COPY_EXISTING "%area_old%.are" "override/%area_new%.are"
       READ_ASCII 0x8 wed_res
       WRITE_ASCIIE 0x8 "%area_new%" (8)
    COPY_EXISTING "%wed_res%.wed" "override/%area_new%.wed"
           WRITE_ASCIIE 0x24 "%area_new%" (8)
    ACTION_IF FILE_EXISTS_IN_GAME "%wed_res%N.tis" BEGIN
       COPY_EXISTING "%wed_res%N.wed" "override/%area_new%N.wed"
              WRITE_ASCIIE 0x24 "%area_new%N" (8)
    END
    COPY_EXISTING "%wed_res%.tis" "override/%area_new%.tis"
    ACTION_IF FILE_EXISTS_IN_GAME "%wed_res%N.tis" BEGIN
       COPY_EXISTING "%wed_res%N.tis" "override/%area_new%N.tis"
    END
    OUTER_INNER_PATCH_SAVE pvrz_res "%wed_res%" BEGIN
       DELETE_BYTES 0x1 1
    END
    OUTER_INNER_PATCH_SAVE pvrz_res_new "%area_new%" BEGIN
       DELETE_BYTES 0x1 1
    END
    OUTER_FOR (j=0;j<10;j+=1) BEGIN
       ACTION_IF FILE_EXISTS_IN_GAME "%pvrz_res%0%j%.pvrz" BEGIN
          COPY_EXISTING "%pvrz_res%0%j%.pvrz" "override/%pvrz_res_new%0%j%.pvrz"
       END
       ACTION_IF FILE_EXISTS_IN_GAME "%pvrz_res%N0%j%.pvrz" BEGIN
          COPY_EXISTING "%pvrz_res%N0%j%.pvrz" "override/%pvrz_res_new%N0%j%.pvrz"
       END
    END
    OUTER_FOR (j=10;j<99;j+=1) BEGIN
       ACTION_IF FILE_EXISTS_IN_GAME "%pvrz_res%%j%.pvrz" BEGIN
          COPY_EXISTING "%pvrz_res%%j%.pvrz" "override/%pvrz_res_new%%j%.pvrz"
       END
       ACTION_IF FILE_EXISTS_IN_GAME "%pvrz_res%N%j%.pvrz" BEGIN
          COPY_EXISTING "%pvrz_res%N%j%.pvrz" "override/%pvrz_res_new%N%j%.pvrz"
       END
    END
    
    ACTION_FOR_EACH map IN sr ht lm ln BEGIN
     ACTION_IF FILE_EXISTS_IN_GAME "%wed_res%%map%.bmp" BEGIN
       COPY_EXISTING "%wed_res%%map%.bmp" "override/%area_new%%map%.bmp"
     END
    END


    // run the changes on the WED (and TIS) file

 ACTION_FOR_EACH area IN "%area_new%" "%area_new%N" BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME "%area%.wed" BEGIN
   COPY_EXISTING "%area%.wed" override


    PATCH_PRINT "cropping doors"
    LPF crop_doors INT_VAR x y xlen ylen END

    PATCH_PRINT "cropping polygons"

    LPF crop_polygons
       INT_VAR x xlen y ylen
    END

    PATCH_PRINT "realigning vertices"
    LPF realign_vertices INT_VAR x y END
    LPF realign_wall_polygon_bbs INT_VAR x y END

    PATCH_PRINT "removing tiles"
    LPF remove_tiles
       INT_VAR x xlen y ylen
    END

    PATCH_PRINT "rebuilding wall groups"
    LPF rebuild_wall_groups END

   BUT_ONLY
  END
 END
  
  // do the area file

  LAF crop_are_file INT_VAR x xlen y ylen STR_VAR area="%area_new%" END

  // do the search maps

  ACTION_FOR_EACH map IN sr ht lm ln BEGIN
   ACTION_IF FILE_EXISTS_IN_GAME "%area_new%%map%.bmp" BEGIN
     COPY_EXISTING "%area_new%%map%.bmp" "override"
       LPF search_map_truncate INT_VAR x y xlen ylen END
   END
  END




END

//////////////////////////////////////////
/// Delete all wallgroups and associated
/// polygons
/// 
/// Here we assume that 
/// (i) the door polygons strictly follow
/// the wall polygons
/// (ii) the door polygons are in order 
/// (so the index of the first door polygon
/// indicates where the door polygons start)
/// (iii) the vertex indexes used by the door 
/// polygons strictly follow those used by
/// the wall polygons
/// (iv) the vertex indexes used by the door
/// polygons again appear in order
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION delete_wallgroups
BEGIN
   // get some data
   READ_LONG 0xc door_num
   READ_LONG 0x18 door_off
   READ_LONG (door_off+0x12) door_polygon_off
   READ_LONG 0x14 sec_header_off
   READ_LONG (sec_header_off) wall_polygon_num
   READ_LONG (sec_header_off + 0x4) polygon_off
   READ_LONG (sec_header_off + 0x8) vertex_off
   READ_LONG (sec_header_off + 0xc) wallgroup_off
   READ_LONG (sec_header_off + 0x10) polygon_index_off
   LPF count_wallgroups RET wallgroup_number=value END
   
   // remove all polygons from wallgroups, leaving the polygons themselves in place

   FOR (wallgroup_ind=0;wallgroup_ind<wallgroup_number;wallgroup_ind+=1) BEGIN
      WRITE_LONG (wallgroup_off + 4*wallgroup_ind) 0
   END

   // delete the unused bytes in the polygon lookup table

   DELETE_BYTES polygon_index_off (vertex_off - polygon_index_off)
   SET vertex_off = polygon_index_off
   WRITE_LONG (sec_header_off + 0x8) vertex_off

   // delete the wall polygons (need to adjust the offsets for door polygons)

   SET wall_polygon_length=0x12*wall_polygon_num
   DELETE_BYTES polygon_off wall_polygon_length
   SET wall_polygon_num=0
   WRITE_LONG sec_header_off wall_polygon_num
   SET polygon_index_off -= wall_polygon_length
   WRITE_LONG (sec_header_off + 0x10) polygon_index_off
   SET vertex_off -= wall_polygon_length
   WRITE_LONG (sec_header_off + 0x8) vertex_off

   FOR (door_ind=0;door_ind<door_num;door_ind+=1) BEGIN
      READ_LONG (0x12 + door_ind*0x1a + door_off) open_off
      SET open_off -=wall_polygon_length
      WRITE_LONG (0x12 + door_ind*0x1a + door_off) open_off
      READ_LONG (0x16 + door_ind*0x1a + door_off) closed_off
      SET closed_off -=wall_polygon_length
      WRITE_LONG (0x16 + door_ind*0x1a + door_off) closed_off
   END

   // delete the unused bytes in the polygons' vertex lookup table
   PATCH_IF door_num>0 BEGIN // read the index of the first door polygon, which should still be around
     READ_LONG polygon_off unused_vertex_count
   END ELSE BEGIN
     SET unused_vertex_count = (BUFFER_LENGTH - vertex_off) / 4
   END
   DELETE_BYTES vertex_off (4*unused_vertex_count)
   FOR (door_ind=0;door_ind<door_num;door_ind+=1) BEGIN
      READ_LONG (0x12 + door_ind*0x1a + door_off) open_off
      READ_SHORT (0xe + door_ind*0x1a + door_off) open_count
      READ_LONG (0x16 + door_ind*0x1a + door_off) closed_off
      READ_SHORT (0x10 + door_ind*0x1a + door_off) closed_count
      FOR (ind=0;ind<open_count;ind+=1) BEGIN
         READ_LONG (open_off + ind*0x12) vertex_ind
         WRITE_LONG (open_off + ind*0x12) (vertex_ind - unused_vertex_count)
      END
      FOR (ind=0;ind<closed_count;ind+=1) BEGIN
         READ_LONG (closed_off + ind*0x12) vertex_ind
         WRITE_LONG (closed_off + ind*0x12) (vertex_ind - unused_vertex_count)
      END
   END

END

//////////////////////////////////////////
/// Rebuild wall groups
/// i.e. go through the wall polygons and
/// build the wall groups from scratch
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION rebuild_wall_groups
BEGIN
     // read in the BB data for each polygon
     READ_LONG 0x14 sec_header_off
     READ_LONG sec_header_off polygon_count
     READ_LONG (sec_header_off+0x4) polygon_off
     FOR (ind=0;ind<polygon_count;ind+=1) BEGIN
        READ_SHORT (ind*0x12 + polygon_off + 0xa) xmin
        READ_SHORT (ind*0x12 + polygon_off + 0xc) xmax
        READ_SHORT (ind*0x12 + polygon_off + 0xe) ymin
        READ_SHORT (ind*0x12 + polygon_off + 0x10) ymax
        SET $xmin("%ind%")=xmin
        SET $xmax("%ind%")=xmax
        SET $ymin("%ind%")=ymin
        SET $ymax("%ind%")=ymax
     END
     // now go through the bounding boxes
     SET bb_ind=0
     READ_SHORT 0x20 width
     READ_SHORT 0x22 height
     SET width=width*0x40
     SET height=height*0x40
     SET polygon_lookup_count=0
     SPRINT polygon_lookup_table ""
     SET y=0 // (x,y) is coordinate of top left corner of map group
     WHILE y<height BEGIN
        SET x=0
        WHILE x<width BEGIN
            SET $group_ind("%bb_ind%")=polygon_lookup_count
            SET polygon_lookup_count_here=0
            SET xmin_2=x
            SET ymin_2=y
            SET xmax_2=x+640
            SET ymax_2=y+480
            // go through each
            FOR (ind=0;ind<polygon_count;ind+=1) BEGIN
                 SET xmin_1=$xmin("%ind%")
                 SET ymin_1=$ymin("%ind%")
                 SET xmax_1=$xmax("%ind%")
                 SET ymax_1=$ymax("%ind%")
                 LPF rectangle_overlap INT_VAR xmin_1 xmax_1 ymin_1 ymax_1 xmin_2 xmax_2 ymin_2 ymax_2 RET overlap END
                 PATCH_IF overlap BEGIN
                    INNER_PATCH_SAVE polygon_lookup_table "%polygon_lookup_table%" BEGIN
                       SET insert_point=BUFFER_LENGTH
                       INSERT_BYTES insert_point 2
                       WRITE_SHORT insert_point ind
                    END
                    SET polygon_lookup_count_here+=1
                 END
            END
            SET $group_count("%bb_ind%")=polygon_lookup_count_here
            SET polygon_lookup_count += polygon_lookup_count_here
            SET bb_ind +=1
            SET x +=640
        END
        SET y +=480
     END
     // now we need to insert the data

     // get all relevant offsets

     READ_LONG (sec_header_off + 0xc) group_off
     READ_LONG (sec_header_off + 0x4) polygon_off
     READ_LONG sec_header_off + 0x8 vertex_off
     READ_LONG sec_header_off + 0x10 polygon_table_off

     // wipe any residual wallgroup cruft

     // first the group indices
     
     SET delete_length_2 = vertex_off - polygon_table_off
     DELETE_BYTES polygon_table_off  delete_length_2
     vertex_off = polygon_table_off

     SET delete_length = polygon_off - group_off
     DELETE_BYTES group_off delete_length
     polygon_off -= delete_length
     vertex_off -= delete_length
     polygon_table_off -= delete_length


     // now insert the new groups (of which there are bb_ind)

     INSERT_BYTES group_off (4*bb_ind)

     // update all the offsets

     polygon_off += 4*bb_ind
     vertex_off += 4*bb_ind
     polygon_table_off += 4*bb_ind

     WRITE_LONG (sec_header_off + 0xc) group_off
     WRITE_LONG (sec_header_off + 0x4) polygon_off
     WRITE_LONG sec_header_off + 0x8 vertex_off
     WRITE_LONG sec_header_off + 0x10 polygon_table_off


     // at this stage, file *should* be legal (although not if there are doors, whose offsets need adjusting)


     // insert the vertices

     SET insert_length=STRING_LENGTH "%polygon_lookup_table%"
     INSERT_BYTES polygon_table_off insert_length
     WRITE_ASCIIE polygon_table_off "%polygon_lookup_table%"
     vertex_off += insert_length
     WRITE_LONG sec_header_off + 0x8 vertex_off

     // fill in the wallgroup data
     FOR (ind=0;ind<bb_ind;ind+=1) BEGIN
        SET group_ind=$group_ind("%ind%")
        SET group_count=$group_count("%ind%")
        WRITE_SHORT (group_off + 0x4*ind) group_ind
        WRITE_SHORT (group_off +0x4*ind + 2) group_count
     END

     // update the polygon offsets inside the doors
     
     READ_LONG 0xc door_count
     READ_LONG 0x18 door_off
     FOR (ind=0;ind<door_count;ind+=1) BEGIN

        READ_LONG 0x12 + ind*0x1a + door_off offset
        WRITE_LONG 0x12 + ind*0x1a + door_off offset+(4*bb_ind - delete_length)
        READ_LONG 0x16 + ind*0x1a + door_off offset
        WRITE_LONG 0x16 + ind*0x1a + door_off offset+(4*bb_ind - delete_length)
     END

END

//////////////////////////////////////////
/// Remove doors that are out of bounds
/// and move the polygons of the rest
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION crop_doors
     INT_VAR x=0
             y=0
             xlen=0
             ylen=0
BEGIN

   xmin=x*0x40
   xmax=(x+xlen)*0x40
   ymin=y*0x40
   ymax=(y+ylen)*0x40
   // get offset data
   READ_LONG 0xc door_count
   READ_LONG 0x18 door_offset_base
   READ_LONG 0x14 sec_header_off
   READ_LONG 0x8+sec_header_off vertex_offset_base
   READ_LONG 0x1c door_tile_offset_base
   READ_SHORT 0x20 width
   READ_SHORT 0x22 height
   SET num_doors_deleted=0
   SET num_door_polygons_deleted=0
   SET num_vertices_deleted=0
   SET num_door_tile_indices_deleted=0
   // get number of wall polygon indices
   READ_LONG sec_header_off wall_polygon_count
   READ_LONG sec_header_off + 4 wall_polygon_offset
   READ_LONG wall_polygon_offset + 0x12* (wall_polygon_count - 1) count_here
   READ_LONG wall_polygon_offset + 0x12* (wall_polygon_count - 1) +4 ind_here
   wall_polygon_index_count=count_here+ind_here
   // go through the doors
   FOR (ind=0;ind<door_count;ind+=1) BEGIN
      SET door_offset = door_offset_base + (ind - num_doors_deleted) * 0x1a
      // adjust tileset indices
      
      READ_SHORT 0xa + door_offset tile_ind_here
      tile_ind_here -= num_door_tile_indices_deleted
      WRITE_SHORT 0xa + door_offset tile_ind_here
      READ_SHORT 0xc + door_offset tile_count_here

      // adjust offsets
      READ_LONG 0x12 + door_offset open_poly_off
      READ_LONG 0x16 + door_offset closed_poly_off

      // this is a TEMPORARY recording. It tracks *only* the deletion of polygons, which needs to
      // be done as we go along. Door and tile renormalisations are at the end
      WRITE_LONG 0x12 + door_offset open_poly_off - num_door_polygons_deleted * 0x12
      WRITE_LONG 0x16 + door_offset closed_poly_off - num_door_polygons_deleted * 0x12

      poly_delta = 0 - num_doors_deleted * 0x1a - num_door_polygons_deleted * 0x12 - num_door_tile_indices_deleted * 2
      open_poly_off += poly_delta   // here I assume door polygons are contiguous
      closed_poly_off += poly_delta


      // go through the polygons; check if the door needs to be deleted, and in any case update indices
      READ_SHORT 0xe+door_offset open_count
      READ_SHORT 0x10+door_offset closed_count
      SET delete=0
      FOR (ind2=0;ind2<open_count;ind2+=1) BEGIN
          offset=open_poly_off + ind2*0x12
          READ_LONG offset ind_here
          ind_here -= num_vertices_deleted
          WRITE_LONG offset ind_here
          READ_SHORT (offset + 0xa) xloc
          READ_SHORT (offset + 0xe) yloc
          PATCH_IF (xloc>=0 && yloc>=0) BEGIN
            LPF point_in_bounds INT_VAR x=xloc y=yloc xmin xmax ymin ymax RET in_bounds END
            PATCH_IF !in_bounds BEGIN
               delete=1
            END
          END
          READ_SHORT (offset + 0xc) xloc
          READ_SHORT (offset + 0x10) yloc
          PATCH_IF (xloc>=0 && yloc>=0) BEGIN
            LPF point_in_bounds INT_VAR x=xloc y=yloc xmin xmax ymin ymax RET in_bounds END
            PATCH_IF !in_bounds BEGIN
               delete=1
            END
          END
      END
      FOR (ind2=0;ind2<closed_count;ind2+=1) BEGIN
          offset=closed_poly_off + ind2*0x12
          READ_LONG offset ind_here
          ind_here -= num_vertices_deleted
          WRITE_LONG offset ind_here
          READ_SHORT (offset + 0xa) xloc
          READ_SHORT (offset + 0xe) yloc
          LPF point_in_bounds INT_VAR x=xloc y=yloc xmin xmax ymin ymax RET in_bounds END
          PATCH_IF !in_bounds BEGIN
             delete=1
          END
          READ_SHORT (offset + 0xc) xloc
          READ_SHORT (offset + 0x10) yloc
          LPF point_in_bounds INT_VAR x=xloc y=yloc xmin xmax ymin ymax RET in_bounds END
          PATCH_IF !in_bounds BEGIN
             delete=1
          END
      END


      /// also check if we need to delete a door because of its tiles
      
      FOR (ind2=0;ind2<tile_count_here;ind2+=1) BEGIN
         READ_SHORT door_tile_offset_base - 0x1a* num_doors_deleted + 0x2 * (ind2+tile_ind_here) tile_number
         LPF remap_this_tile INT_VAR tile_number x xlen y ylen width height RET value END
         PATCH_IF value<0 BEGIN
            PATCH_IF !delete BEGIN
            END
            delete=1
         END
      END

      // if we're deleting...
      PATCH_IF delete BEGIN
         // first do the vertices - second pass through the polygons
         num_deleted_here=0
         FOR (ind2=0;ind2<open_count;ind2+=1) BEGIN
           offset=open_poly_off + ind2*0x12
           READ_LONG offset ind_here
           READ_LONG offset+4 count_here
           PATCH_IF count_here>0 BEGIN
            vertex_offset = vertex_offset_base - num_doors_deleted * 0x1a  - num_door_tile_indices_deleted * 2 - num_door_polygons_deleted * 0x12 + (ind_here - num_deleted_here)  * 0x4
            DELETE_BYTES vertex_offset (4*count_here)

            // we do this just to keep the code modular, so we can test this bit works - they're about to be deleted
            WRITE_LONG offset (ind_here - num_deleted_here)
            WRITE_LONG offset+4 0

            num_vertices_deleted +=count_here
            num_deleted_here += count_here

           END
         END
          num_open_deleted_here = num_deleted_here

         FOR (ind2=0;ind2<closed_count;ind2+=1) BEGIN
           offset=closed_poly_off + ind2*0x12
           READ_LONG offset ind_here
           READ_LONG offset+4 count_here
           PATCH_IF count_here>0 BEGIN
            vertex_offset = vertex_offset_base - num_doors_deleted * 0x1a  - num_door_tile_indices_deleted * 2 - num_door_polygons_deleted * 0x12 + (ind_here - num_deleted_here) * 0x4
           DELETE_BYTES vertex_offset (4*count_here)

            // we do this just to keep the code modular, so we can test this bit works - they're about to be deleted
            WRITE_LONG offset (ind_here - num_deleted_here)
            WRITE_LONG offset+4 0

            num_vertices_deleted +=count_here
            num_deleted_here +=count_here

           END
         END

         // now delete the actual polygons

         DELETE_BYTES open_poly_off 0x12*open_count
         closed_poly_off -=0x12*open_count
         DELETE_BYTES closed_poly_off 0x12*closed_count
         num_door_polygons_deleted += (closed_count + open_count)
         // we do this just to keep the code modular, so we can test this bit works - they're about to be deleted
         WRITE_SHORT 0xe+door_offset 0
         WRITE_SHORT 0x10+door_offset 0
         // update the closed-polygon index to allow for deletions (only relevant so that we can test partway through)
         WRITE_LONG 0x16 + door_offset closed_poly_off


         // now delete the door tile indices

         tile_ind_off = door_tile_offset_base + tile_ind_here * 2
         READ_SHORT tile_ind_off - 0x1a* num_doors_deleted  data
         DELETE_BYTES tile_ind_off - 0x1a* num_doors_deleted  (2*tile_count_here)
         num_door_tile_indices_deleted +=tile_count_here
         WRITE_SHORT (0xc + door_offset) 0


         // last but not least, delete the actual door

         DELETE_BYTES door_offset 0x1a
         num_doors_deleted +=1


      END // end of DELETE loop

   END // end of loop through doors

   // update offsets

   // door tile cell indices
   READ_LONG 0x1c door_tile_offset_base
   WRITE_LONG 0x1c (door_tile_offset_base - 0x1a* num_doors_deleted)

   // tile indices and tilemaps
   READ_LONG 0x8 overlay_count
   READ_LONG 0x10 overlay_off
   FOR (ind=0;ind<overlay_count;ind+=1) BEGIN
      READ_LONG (0x10 + overlay_off + ind*0x18) offset
      WRITE_LONG (0x10 + overlay_off + ind*0x18) ( offset - 0x1a* num_doors_deleted)
      READ_LONG (0x14 + overlay_off + ind*0x18) offset
      WRITE_LONG (0x14 + overlay_off + ind*0x18) ( offset - 0x1a* num_doors_deleted  - num_door_tile_indices_deleted * 2)
   END
   // wall groups
   READ_LONG sec_header_off + 0xc wall_offset
   WRITE_LONG sec_header_off + 0xc (wall_offset - 0x1a* num_doors_deleted - num_door_tile_indices_deleted * 2)
   // polygons
   READ_LONG sec_header_off + 0x4 poly_offset
   WRITE_LONG sec_header_off + 0x4 (poly_offset - 0x1a* num_doors_deleted - num_door_tile_indices_deleted * 2)
   // polygon indices
   READ_LONG sec_header_off + 0x10 poly_index_offset
   WRITE_LONG sec_header_off + 0x10 (poly_index_offset - 0x12 * num_door_polygons_deleted - 0x1a * num_doors_deleted  - num_door_tile_indices_deleted * 2)
   // vertices
   WRITE_LONG sec_header_off + 0x8 (vertex_offset_base - 0x12 * num_door_polygons_deleted - 0x1a * num_doors_deleted  - num_door_tile_indices_deleted * 2)

   // update number of doors

   door_count -= num_doors_deleted
   WRITE_LONG 0xc door_count

   // update door offsets
   // they are already updated for polygon changes, but they need renormalising after door/index deletions

   FOR (ind=0;ind<door_count;ind+=1) BEGIN
      READ_LONG (0x12 + door_offset_base + 0x1a*ind) offset
      WRITE_LONG (0x12 + door_offset_base + 0x1a*ind) (offset - 0x1a* num_doors_deleted - num_door_tile_indices_deleted * 2)
      READ_LONG (0x16 + door_offset_base + 0x1a*ind) offset
      WRITE_LONG (0x16 + door_offset_base + 0x1a*ind) (offset - 0x1a* num_doors_deleted - num_door_tile_indices_deleted * 2)
   END

END



//////////////////////////////////////////
/// Remove tiles from a WED, on the assumption
/// we're cropping
//////////////////////////////////////////


DEFINE_PATCH_FUNCTION remove_tiles
     INT_VAR x=0
             y=0
             xlen=0
             ylen=0
BEGIN
// sanity check
			LPF check_wed_for_multiples RET value END
			PATCH_IF value BEGIN
				PATCH_WARN "Wed file %SOURCE_RES% uses multiple primary tiles; crop_area probably won't work for it"
			END
// delete the unwanted tiles
           SPRINT this_file "%SOURCE_RES%"
           SET bytes_deleted=0
           SET tiles_deleted=0
           SPRINT new_tile_indices ""
           // get some data
           READ_LONG 0x10 overlay_off
           READ_LONG (overlay_off+0x14) tile_ind_off
           READ_LONG (overlay_off+0x10) tile_structure_off
           READ_SHORT overlay_off width
           READ_SHORT (overlay_off+2) height
           SET tile_count=width * height
           // sanity check
           PATCH_IF (x+xlen)>width BEGIN
              PATCH_WARN "clip is out of bounds; truncating"
              xlen = width - x
           END
           PATCH_IF (y+ylen)>height BEGIN
              PATCH_WARN "clip is out of bounds; truncating"
              ylen = height - y
           END
           // adjust height/width
           WRITE_SHORT overlay_off xlen
           WRITE_SHORT (overlay_off+2) ylen
           // go through the tile structures in the primary layer
           FOR (tile_structure_ind=0;tile_structure_ind<tile_count;tile_structure_ind+=1) BEGIN
              READ_LONG 0x14 sec_header_off
              LPF remap_this_tile INT_VAR tile_number=tile_structure_ind x y xlen ylen height width RET value END
              PATCH_IF value<0 BEGIN
                 SET delete_loc=tile_structure_off + 0xa*tile_structure_ind - bytes_deleted
                 DELETE_BYTES delete_loc 0xa
                 SET bytes_deleted +=0xa
                 SET tiles_deleted +=1
              END ELSE BEGIN
                 READ_SHORT (tile_structure_off + tile_structure_ind*0xa - bytes_deleted) tile_ind
                 // remap the (presumed unique) primary tile
                 READ_ASCII (tile_ind_off - bytes_deleted +tile_ind*2) data (2)
                 READ_SHORT (tile_ind_off - bytes_deleted +tile_ind*2) tile_number
                 LPF remap_this_tile INT_VAR tile_number x y xlen ylen height width RET value END
                 INNER_PATCH_SAVE new_tile_indices "%new_tile_indices%" BEGIN
                    SET insert_point=BUFFER_LENGTH
                    INSERT_BYTES insert_point 2
                    WRITE_SHORT insert_point value
                 END
                 SET tile_ind -=tiles_deleted
                 WRITE_SHORT (tile_structure_off + tile_structure_ind*0xa - bytes_deleted) tile_ind
                 // adjust any secondary tile
                 READ_SSHORT (0x4 + tile_structure_off + tile_structure_ind*0xa - bytes_deleted) sec_tile_number
                 PATCH_IF sec_tile_number>=0 BEGIN
                    LPF remap_this_tile INT_VAR tile_number=sec_tile_number x y xlen ylen height width RET value END
                    PATCH_IF value>=0 BEGIN
                       WRITE_SHORT (0x4 + tile_structure_off + tile_structure_ind*0xa - bytes_deleted) value
                    END ELSE BEGIN
                       PATCH_WARN "secondary tile %sec_tile_number%, at %tile_structure_ind%, appears to be in the height*width space; ignoring"
                    END
                 END
              END
           END
           
           // adjust the tile lookups for door tiles
           // (doors themselves occur directly after
           // the secondary header, so don't have to
           // be reindexed). And doors have already
           // been cropped, so no need to worry about
           // bounds

           READ_LONG 0xc door_count
           READ_LONG 0x18 door_off
           READ_LONG 0x1c door_tile_off
           door_tile_off -=bytes_deleted
           WRITE_LONG 0x1c door_tile_off
           PATCH_IF door_count>0 BEGIN
            READ_SHORT (door_off + 0x1a* (door_count - 1) +0xa) ind_here
            READ_SHORT (door_off + 0x1a* (door_count - 1) + 0xc) count_here
            door_tile_count=ind_here+count_here
            FOR (ind=0;ind<door_tile_count;ind+=1) BEGIN

              READ_SHORT door_tile_off + 2 *ind tile_number
              LPF remap_this_tile INT_VAR tile_number x y xlen ylen height width RET value END
              WRITE_SHORT door_tile_off + 2 *ind value
              PATCH_IF value <0 BEGIN
              //   PATCH_WARN "Something wrong: a door tile is out of bounds"
              END
            END
           END



           // adjust offsets inside headers
           READ_LONG 0x14 sec_header_off
           FOR (i=4;i<0x14;i+=4) BEGIN
              READ_LONG (sec_header_off+i) offset
              SET offset -=bytes_deleted
              WRITE_LONG (sec_header_off+i) offset
           END

           // adjust tile index offset inside base layer
           READ_LONG (0x14+overlay_off) offset
           SET offset -=bytes_deleted
           WRITE_LONG (0x14+overlay_off) offset

           // replace the tile index lookup table
           READ_LONG (overlay_off+0x14) tile_ind_off
           SET bytes_deleted2 = tile_count *2 - STRING_LENGTH "%new_tile_indices%"
           DELETE_BYTES tile_ind_off bytes_deleted2
           WRITE_ASCIIE tile_ind_off "%new_tile_indices%"
           
           ////////
           // Another round of offset adjustments
           ////////


           // adjust offsets inside headers
           READ_LONG 0x14 sec_header_off
           FOR (i=4;i<0x14;i+=4) BEGIN
              READ_LONG (sec_header_off+i) offset
              SET offset -=bytes_deleted2
              WRITE_LONG (sec_header_off+i) offset
           END

           // adjust any offsets inside overlays

           FOR (i=1;i<5;i+=1) BEGIN
              READ_LONG (0x18*i+overlay_off+0x10) offset
              SET offset -= bytes_deleted
              WRITE_LONG (0x18*i+overlay_off+0x10) offset
              READ_LONG (0x18*i+overlay_off+0x14) offset
              SET offset -= (bytes_deleted2+bytes_deleted)
              WRITE_LONG (0x18*i+overlay_off+0x14) offset
           END

           // adjust any offsets inside doors
           // (this we do in one go)
           
           READ_LONG 0x18 door_off
           FOR (ind=0;ind<door_count;ind+=1) BEGIN
               READ_LONG door_off + 0x1a*ind + 0x12 off
               WRITE_LONG door_off + 0x1a*ind + 0x12 (off - bytes_deleted - bytes_deleted2)
               READ_LONG door_off + 0x1a*ind + 0x16 off
               WRITE_LONG door_off + 0x1a*ind + 0x16 (off - bytes_deleted - bytes_deleted2)

           END

           
           // remap the TIS file
           READ_ASCII 0x24 tis_file
           INNER_ACTION BEGIN
                 COPY_EXISTING "%tis_file%.tis" override
                      READ_LONG 0x8 tis_tile_count
                      SET tis_tiles_deleted=0
                      FOR (tis_tile_ind=0;tis_tile_ind<tis_tile_count;tis_tile_ind+=1) BEGIN
                         LPF remap_this_tile INT_VAR x xlen y ylen height width tile_number=tis_tile_ind RET value END
                         PATCH_IF value<0 BEGIN
                            SET tis_delete_offset=(tis_tile_ind - tis_tiles_deleted)*0xc + 0x18
                            DELETE_BYTES tis_delete_offset 0xc
                            SET tis_tiles_deleted +=1
                         END
                      END
                      SET tis_tile_count -=tis_tiles_deleted
                      WRITE_LONG 0x8 tis_tile_count


                 BUT_ONLY
             END


END



//////////////////////////////////////////
/// Check if a WED file uses the multiple-tile
/// functionality (used for things like flapping flags
/// in Candlekeep and some fireplaces; not currently
/// supported in crop_area
///////////////////////////////////////////

DEFINE_PATCH_FUNCTION check_wed_for_multiples
	RET value
BEGIN
	value=0
	tile_count = (SHORT_AT 0x20) * (SHORT_AT 0x22)
	READ_LONG 0x30 tile_off
	FOR (ind=0;ind<tile_count;ind+=1) BEGIN
		READ_BYTE (tile_off + ind*0xa + 2) count
		PATCH_IF count>1 BEGIN
			value=1
		END
	END
END


//////////////////////////////////////////
/// Move the vertices in to the top left
/// corner (x,y are in tiles)
///////////////////////////////////////////

DEFINE_PATCH_FUNCTION realign_vertices
    INT_VAR x=0
            y=0
BEGIN
     READ_LONG 0x14 sec_header_off
     READ_LONG 0x8+sec_header_off vertex_off
     offset=vertex_off
     WHILE vertex_off<BUFFER_LENGTH BEGIN
        WRITE_SHORT vertex_off ((SHORT_AT vertex_off) - x*0x40 )
        vertex_off +=2
        WRITE_SHORT vertex_off ((SHORT_AT vertex_off) - y*0x40 )
        vertex_off +=2
     END
END

//////////////////////////////////////////
/// Move the wall-polygon bounding boxes in to the top left
/// corner (x,y are in tiles)
///////////////////////////////////////////

DEFINE_PATCH_FUNCTION realign_wall_polygon_bbs
    INT_VAR x=0
            y=0
BEGIN
     READ_LONG 0x14 sec_header_off
     READ_LONG 0x4+sec_header_off offset
     READ_LONG sec_header_off count
     FOR (ind=0;ind<count;ind+=1) BEGIN
        SET offset_here=offset+ind*0x12
        WRITE_SHORT (offset_here + 0xa) (SHORT_AT (offset_here+0xa) - x*0x40 )
        WRITE_SHORT (offset_here + 0xc) (SHORT_AT (offset_here+0xc) - x*0x40 )
        WRITE_SHORT (offset_here + 0xe) (SHORT_AT (offset_here+0xe) - y*0x40 )
        WRITE_SHORT (offset_here + 0x10) (SHORT_AT (offset_here+0x10) - y*0x40 )
     END
END

//////////////////////////////////////////
/// Crop the wall polygons
///////////////////////////////////////////

DEFINE_PATCH_FUNCTION crop_polygons
    INT_VAR x=0
            xlen=0
            y=0
            ylen=0
BEGIN
     READ_LONG 0x14 sec_header_off
     READ_LONG sec_header_off polygon_count
     PATCH_IF polygon_count>0 BEGIN
       READ_LONG sec_header_off + 0x4 polygon_off
       READ_LONG sec_header_off + 0x8 vertex_off
       READ_ASCII polygon_off polygons (0x12*polygon_count)
       // check the last polygon to get the vertex count
       READ_SHORT (polygon_off + 0x12*(polygon_count - 1)) ind
       READ_SHORT (polygon_off + 0x12*(polygon_count - 1) + 4) count_here
       SET vertex_count=ind+count_here
       READ_ASCII vertex_off vertices (0x4*vertex_count)
       LPF clip_polygon_block INT_VAR x xlen y ylen STR_VAR polygons_in="%polygons%" vertices_in="%vertices%" RET polygons_out vertices_out END
       LPF insert_polygon_block STR_VAR polygons="%polygons_out%" vertices="%vertices_out%" END
     END
END




//////////////////////////////////////////
/// Given a block of polygons and another
/// of vertices, insert then into a file as
/// its wall group (destructive overwrite)
///////////////////////////////////////////

DEFINE_PATCH_FUNCTION insert_polygon_block
     STR_VAR polygons=""
             vertices=""
BEGIN
	 LPF delete_wallgroups END
     SET polygon_length=STRING_LENGTH "%polygons%"
     SET vertex_length=STRING_LENGTH "%vertices%"
     SET polygon_count=polygon_length / 0x12
     SET vertex_count=vertex_length / 4
     READ_LONG 0x14 sec_header_off
     WRITE_LONG sec_header_off polygon_count
     READ_LONG sec_header_off + 0x4 polygon_off
     READ_LONG sec_header_off + 0x8 vertex_off
     SET vertex_off +=polygon_length
     WRITE_LONG sec_header_off + 0x8 vertex_off
     READ_LONG sec_header_off + 0x10 polygon_ind_off
     SET polygon_ind_off +=polygon_length
     WRITE_LONG sec_header_off + 0x10 polygon_ind_off
     INSERT_BYTES polygon_off polygon_length
     WRITE_ASCIIE polygon_off "%polygons%"
     INSERT_BYTES vertex_off vertex_length
     WRITE_ASCIIE vertex_off "%vertices%"
     // we need to adjust doors to point to the right polygons, and door polygons to point to the right indices
     READ_LONG 0xc door_count
     READ_LONG 0x18 door_offset
     FOR (ind=0;ind<door_count;ind+=1) BEGIN
        READ_LONG (0x12 + ind*0x1a + door_offset) open_offset
        open_offset +=polygon_length
        WRITE_LONG (0x12 + ind*0x1a + door_offset) open_offset
        READ_LONG (0x16 + ind*0x1a + door_offset) closed_offset
        closed_offset +=polygon_length
        WRITE_LONG (0x16 + ind*0x1a + door_offset) closed_offset
        READ_SHORT (0xe + ind*0x1a + door_offset) open_count
        READ_SHORT (0x10 + ind*0x1a + door_offset) closed_count
        FOR (ind2=0;ind2<open_count;ind2+=1) BEGIN
           READ_LONG (ind2*0x12 + open_offset) ind_here
           ind_here +=vertex_count
           WRITE_LONG (ind2*0x12 + open_offset) ind_here
        END
        FOR (ind2=0;ind2<closed_count;ind2+=1) BEGIN
           READ_LONG (ind2*0x12 + closed_offset) ind_here
           ind_here +=vertex_count
           WRITE_LONG (ind2*0x12 + closed_offset) ind_here
        END
     END

END

//////////////////////////////////////////
/// Input a block of polygons, and their indices. Output a
/// block of polygons clipped to a (pixel-specified)
/// area
///////////////////////////////////////////

DEFINE_PATCH_FUNCTION clip_polygon_block
    INT_VAR x=0
            xlen=0
            y=0
            ylen=0
    STR_VAR polygons_in=""
            vertices_in=""
    RET polygons_out vertices_out
BEGIN
    SET x=x*0x40
    SET y=y*0x40
    SET xlen=xlen*0x40
    SET ylen=ylen*0x40
    SPRINT polygons_out ""
    SPRINT vertices_out ""
    SET vertex_count=0
    SET polygon_count=0
    SET new_polygon_count=0
    WHILE STRING_LENGTH "%polygons_in%">0 BEGIN
       // get polygon data
       INNER_PATCH_SAVE polygons_in "%polygons_in%" BEGIN
         READ_LONG 0x0 start_ind
         READ_LONG 0x4 count_ind
         READ_BYTE 0x8 flags
         READ_BYTE 0x9 unknown
         READ_SHORT 0xa xmin
         READ_SHORT 0xc xmax
         READ_SHORT 0xe ymin
         READ_SHORT 0x10 ymax
         DELETE_BYTES 0x0 0x12
       END
       // is the polygon a hovering wall? (The first 2 points in those polygons behave differently)
       SET hovering_wall= ( (flags BOR 0b11111011) = 0b11111111)

       // get polygon vertex data
       // in string form (assuming there are any vertices)
	   PATCH_IF count_ind>0 BEGIN
       INNER_PATCH "%vertices_in%" BEGIN
          PATCH_IF hovering_wall BEGIN
               READ_ASCII 4*start_ind hovering_wall_vertices (8)
               READ_ASCII (4*start_ind+8) vertices_here (4*count_ind - 8)
          END ELSE BEGIN
               READ_ASCII 4*start_ind vertices_here (4*count_ind)
          END
          READ_ASCII 4*start_ind vertices_here (4*count_ind)
          READ_ASCII 4*start_ind hovering_wall_vertices (8)
       END
	   END
       PATCH_IF hovering_wall && count_ind>0 BEGIN
          LPF truncate_wall
                  INT_VAR xmin=x
                          ymin=y
                          xmax=x + xlen
                          ymax=y + ylen
                  STR_VAR vertices="%hovering_wall_vertices%" 
          RET hovering_wall_vertices=vertices in_bounds END
       END ELSE BEGIN
          SET in_bounds=1
       END
       // is the polygon in bounds?
       PATCH_IF (xmax>x) &&(ymax>y) && (xmin < (x + xlen)) && (ymin < (y + ylen)) && count_ind>0 BEGIN
           
		   SET bb_ymax=ymax
		   LPF truncate_polygon
                  INT_VAR xmin=x
                          ymin=y
                          xmax=x + xlen
                          ymax=y + ylen
						  bb_ymax
                  STR_VAR vertices="%vertices_here%"
                  RET vertices_here=vertices
                      xmin=bb_xmin
                      xmax=bb_xmax
                      ymin=bb_ymin
                      ymax=bb_ymax
           END
           // sanity check: are there at least 3 vertices? If not, abort the
           // whole thing
           PATCH_IF STRING_LENGTH "%vertices_here%" >=12 BEGIN
            PATCH_IF hovering_wall BEGIN
              SPRINT vertices_here "%hovering_wall_vertices%"^"%vertices_here%"
            END
            SET count_here=(STRING_LENGTH "%vertices_here%")/4
            SPRINT vertices_out "%vertices_out%"^"%vertices_here%"
            SET count_here = (STRING_LENGTH "%vertices_here%") / 4
            INNER_PATCH_SAVE polygons_out "%polygons_out%" BEGIN
                 SET insert_point=BUFFER_LENGTH
                 INSERT_BYTES insert_point 0x12
                 WRITE_LONG insert_point vertex_count
                 WRITE_LONG (insert_point + 4) count_here
                 WRITE_BYTE (insert_point + 8) flags
                 WRITE_BYTE (insert_point + 9) unknown
                 WRITE_SHORT (insert_point + 0xa) xmin
                 WRITE_SHORT (insert_point + 0xc) xmax
                 WRITE_SHORT (insert_point + 0xe) ymin
                 WRITE_SHORT (insert_point + 0x10) ymax
            END
            SET vertex_count += count_here
            SET new_polygon_count +=1
           END
       END
       polygon_count +=1
    END  // end of WHILE loop
END


//////////////////////////////////////////
/// Return -1 if a tile is to be cropped,
/// or its new number otherwise
/// (x,y) measured from top left
///////////////////////////////////////////

DEFINE_PATCH_FUNCTION remap_this_tile
   INT_VAR x=0
           xlen=0
           y=0
           ylen=0
           height=0
           width=0
           tile_number=0
   RET value
BEGIN
    tile_number_orig=tile_number
    // catch 'special' tiles
    PATCH_IF tile_number>=height*width BEGIN
        SET value=tile_number + (xlen * ylen) - (height * width)
    END ELSE BEGIN
        // work out the tile's coordinates
        SET yloc=0
        WHILE tile_number>=width BEGIN
            SET yloc+=1
            SET tile_number -=width
        END
        SET xloc=tile_number
        PATCH_IF (xloc<x || yloc<y ||xloc>=x+xlen || yloc>=y+ylen) BEGIN
           SET value="-1"
        END ELSE BEGIN
          // assuming we're not deleting it, work out its new value
          SET xloc_new =xloc - x
          SET yloc_new =yloc - y
          SET value=yloc_new*xlen + xloc_new
        END
    END
   // PATCH_PRINT "remap: %tile_number_orig%->%value% (tile was at %xloc%,%yloc%; bounds were (%x%->%x%+%xlen%) x (%y%->%y%+%ylen%))"

END

//////////////////////////////////////////
/// Find how many wallgroups a wed should have
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION count_wallgroups
RET value
BEGIN
   READ_LONG 0x10 overlay_off
   READ_SHORT overlay_off tiles_x
   READ_SHORT (overlay_off+2) tiles_y
   LPF divide_round_up INT_VAR numerator=tiles_x denominator=10 RET num_x=value END
   LPF divide_round_up INT_VAR numerator=2*tiles_y denominator=15 RET num_y=value END
   SET value=num_x * num_y
END

//////////////////////////////////////////
/// Divide two numbers, rounding up
/// any remainder
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION divide_round_up
   INT_VAR numerator=0
           denominator=0
   RET value
BEGIN
   PATCH_IF (numerator / denominator) * denominator = numerator BEGIN
      SET value = numerator / denominator
   END ELSE BEGIN
      SET value = (numerator / denominator) + 1
   END
END

//////////////////////////////////////////
/// Flip an area along its vertical axis
///
/// You need to supply (in 'file_loc') 
/// a properly-named TIS file and associated
/// PVRZ files, plus (for legacy use) a legacy
/// TIS file with a 'v' name suffix, plus
/// the height,search and light maps
///
/// DO NOT do the inversion in Paint, as it apparently
/// scrambles transparency layers. Photoshop works.
///
/// You can also pass the program an array
/// of scripts (in the form $[script_array]("[script]")="")
/// whose coordinates need to be
/// inverted
//////////////////////////////////////////


DEFINE_ACTION_FUNCTION flip_area
   STR_VAR area=""
           file_loc=""
           script_array=""
BEGIN
   // get the wed file
   COPY_EXISTING "%area%.are" override
           READ_ASCII 0x8 wed
   BUT_ONLY
   // edit the wed file
   ACTION_IF !FILE_EXISTS_IN_GAME "%wed%.wed" BEGIN
		FAIL "The WED file %wed%.wed does not exist"
   END
   COPY_EXISTING 
   "%wed%.wed" override
   "%wed%n.wed" override
        // get the width in pixels of the area
        READ_LONG 0x10 overlay_off
        READ_SHORT overlay_off num_tiles_x
        READ_SHORT overlay_off+2 num_tiles_y
        SET width_total=num_tiles_x*0x40
        // get vertex, polygon offsets
        READ_LONG 0x14 sec_header_off
        READ_LONG (0x8+sec_header_off) initial_vertex_offset
        READ_LONG sec_header_off wall_polygon_number
        READ_LONG (0x4 + sec_header_off) initial_polygon_offset
        // go through polygons
        FOR (n=0;n<wall_polygon_number;n+=1) BEGIN
           SET polygon_offset = initial_polygon_offset + 0x12 * n
           READ_LONG polygon_offset initial_vertex_index
           READ_LONG polygon_offset+4 vertex_number
           // vertex inversion
		   FOR (ind=initial_vertex_index;ind<initial_vertex_index + vertex_number; ind +=1) BEGIN
              LPF flip_vertex INT_VAR width_total offset=ind*4+initial_vertex_offset END
           END
           // bounding box inversion
           LPF flip_bounding_box INT_VAR layout=1 offset=polygon_offset+0xa width_total END
        END
        SET tilemap_start=LONG_AT (0x10 + overlay_off)
		SET tile_lookup_start = LONG_AT (0x14 + overlay_off)
		new_tile_ind=0
		new_tile_lookup_ind=0
		// go through existing primary tileset and work out the new tileset (store in arrays)
		FOR (y=0;y<num_tiles_y;y+=1) BEGIN
			FOR (x=0;x<num_tiles_x;x+=1) BEGIN
				offset_old=tilemap_start + 0xa*(y*num_tiles_x + (num_tiles_x - x - 1) ) // go R to L through existing array
					READ_SHORT offset_old first_tile_here
					READ_SHORT (offset_old + 2) tile_count_here
					SET $new_ind_arr("%new_tile_ind%")=new_tile_lookup_ind
					SET $new_count_arr("%new_tile_ind%")=tile_count_here
					FOR (i=first_tile_here;i<first_tile_here + tile_count_here;i+=1) BEGIN
						READ_SHORT (tile_lookup_start + 2*i) tile_number
						LPF flip_tile INT_VAR height=num_tiles_y width=num_tiles_x tile_number RET new_number END
						SET $new_lookup_arr("%new_tile_lookup_ind%")=new_number
						new_tile_lookup_ind +=1
					END
					READ_SSHORT (offset_old + 4) tile_number
					PATCH_IF tile_number>=0 BEGIN
						LPF flip_tile INT_VAR height=num_tiles_y width=num_tiles_x tile_number RET new_number END	
						SET $new_secondary_arr("%new_tile_ind%")=new_number	
					END ELSE BEGIN
						SET $new_secondary_arr("%new_tile_ind%") = "-1"
					END
					READ_BYTE (offset_old + 6) flags
					SET $new_flags_arr("%new_tile_ind%")=flags				
				// move on to next index
				new_tile_ind+=1
			END
		END
		// write the new tileset
		FOR (ind=0;ind<num_tiles_x * num_tiles_y; ind+=1) BEGIN
			offset_here=tilemap_start + 0xa*ind
			tile_ind_here=$new_ind_arr("%ind%")
			tile_count_here=$new_count_arr("%ind%")
			secondary_here=$new_secondary_arr("%ind%")
			flags_here=$new_flags_arr("%ind%")
			WRITE_SHORT offset_here tile_ind_here
			WRITE_SHORT (offset_here + 2) tile_count_here
			WRITE_SHORT (offset_here + 4) secondary_here
			WRITE_BYTE (offset_here + 6) flags_here
		END
		// write the new lookups
		FOR (ind=0;ind<new_tile_lookup_ind;ind+=1) BEGIN
			lookup_here=$new_lookup_arr("%ind%")
			WRITE_SHORT (tile_lookup_start + 2*ind) lookup_here
		END


		/*
        // go through the primary array and build an array of which tiles get remapped to which
		FOR (ind=0;ind<num_tiles_x*num_tiles_y;ind+=1) BEGIN
           READ_SSHORT (tilemap_start + ind*0xa + 0x4) sec_tile
           PATCH_IF sec_tile>=0 BEGIN
              SET $sec_tiles("%ind%")=sec_tile
           END
           READ_BYTE (tilemap_start + ind*0xa + 0x6) overlay_flags
           PATCH_IF overlay_flags>0 BEGIN
              SET $tile_overlay_flags("%ind%")=overlay_flags
              WRITE_BYTE (tilemap_start + ind*0xa + 0x6) 0
              WRITE_SHORT (tilemap_start + ind*0xa + 0x4)  "-1"
           END
		   READ_SHORT (tilemap_start + ind*0xa + 0x2) num_tiles
		   PATCH_IF num_tiles>0 BEGIN
				
		   END
        END

        // go through and make changes
        PHP_EACH sec_tiles AS primary_ind=>secondary_ind BEGIN
           LPF flip_tile INT_VAR height=num_tiles_y width=num_tiles_x tile_number=primary_ind RET new_primary=new_number END
           LPF flip_tile INT_VAR height=num_tiles_y width=num_tiles_x tile_number=secondary_ind RET new_secondary=new_number END
           WRITE_SHORT (tilemap_start + new_primary*0xa + 0x4) new_secondary
        END
        PHP_EACH tile_overlay_flags AS primary_ind=>flag BEGIN
           LPF flip_tile INT_VAR height=num_tiles_y width=num_tiles_x tile_number=primary_ind RET new_primary=new_number END
           flags = $tile_overlay_flags("%primary_ind%")
           WRITE_BYTE (tilemap_start + new_primary*0xa + 0x6) flags
        END
		*/

        // remap doors
        
        READ_LONG 0xc num_doors
        READ_LONG 0x18 door_off
        READ_LONG 0x1c door_tile_off
        FOR (ind=0;ind<num_doors;ind+=1) BEGIN
           // flip tiles
           READ_SHORT (0xa + 0x1a * ind + door_off) door_tile_ind
           READ_SHORT (0xc + 0x1a * ind + door_off) door_tile_count
           FOR (ind2=0;ind2<door_tile_count;ind2+=1) BEGIN 
              READ_SHORT ( (ind2 + door_tile_ind)*2 + door_tile_off) tile_number
              LPF flip_tile INT_VAR height=num_tiles_y width=num_tiles_x tile_number RET new_number END
              WRITE_SHORT ((ind2 + door_tile_ind)*2 + door_tile_off) new_number
           END
           // flip polygons
           READ_SHORT (0xe + 0x1a * ind + door_off) polygon_number
           READ_LONG (0x12 + 0x1a * ind + door_off) polygon_offset_base
           FOR (j=0;j<polygon_number;j+=1) BEGIN
               // flip vertices (NB still needs a rotation to make sure we lead with rightmost index)
               polygon_offset=polygon_offset_base + 0x12*j
               READ_LONG polygon_offset initial_vertex_index
               READ_LONG polygon_offset+4 vertex_number
               LPF invert_vertex_sequence_order INT_VAR initial_vertex_offset initial_vertex_index vertex_number width_total END
               // bounding box inversion
               LPF flip_bounding_box INT_VAR layout=1 offset=polygon_offset+0xa width_total END
           END
           READ_SHORT (0x10 + 0x1a * ind + door_off) polygon_number
           READ_LONG (0x16 + 0x1a * ind + door_off) polygon_offset_base
           FOR (j=0;j<polygon_number;j+=1) BEGIN
               // flip vertices (NB still needs a rotation to make sure we lead with rightmost index)
               polygon_offset=polygon_offset_base + 0x12*j
               READ_LONG polygon_offset initial_vertex_index
               READ_LONG polygon_offset+4 vertex_number
               LPF invert_vertex_sequence_order INT_VAR initial_vertex_offset initial_vertex_index vertex_number width_total END
               // bounding box inversion
               LPF flip_bounding_box INT_VAR layout=1 offset=polygon_offset+0xa width_total END
           END

        END
        // rebuild wall groups
        LPF rebuild_wall_groups END
   BUT_ONLY
   IF_EXISTS
   
   // invert the area file
   COPY_EXISTING "%area%.are" override
      // invert all vertices
      READ_LONG 0x7c vert_off
      READ_SHORT 0x80 vert_num
      // flip actor locations
      GET_OFFSET_ARRAY act_arr ARE_V10_ACTORS
      PHP_EACH act_arr AS ind=>act_off BEGIN
         LPF flip_vertex INT_VAR width_total offset=act_off+0x20 END
         LPF flip_vertex INT_VAR width_total offset=act_off+0x24 END
         LPF flip_orientation INT_VAR offset=0x34+act_off END
      END
      // flip regions
      GET_OFFSET_ARRAY reg_arr ARE_V10_REGIONS
      PHP_EACH reg_arr AS ind=>reg_off BEGIN
         LPF flip_bounding_box INT_VAR layout=2 width_total offset=reg_off+0x22 END
         LPF flip_vertex INT_VAR width_total offset=reg_off+0x70 END
         LPF flip_vertex INT_VAR width_total offset=reg_off+0x84 END
         READ_SHORT reg_off+0x2c initial_vertex_index
         READ_SHORT reg_off+0x2a vertex_number
         LPF invert_vertex_sequence_order INT_VAR initial_vertex_offset=vert_off initial_vertex_index vertex_number width_total END

      END
      // flip spawn points
      GET_OFFSET_ARRAY spawn_arr ARE_V10_SPAWN_POINTS
      PHP_EACH spawn_arr AS ind=>spawn_off BEGIN
         LPF flip_vertex INT_VAR width_total offset=spawn_off+0x20 END
      END
      // flip entrances
      GET_OFFSET_ARRAY ent_arr ARE_V10_ENTRANCES
      PHP_EACH ent_arr AS ind=>ent_off BEGIN
         LPF flip_vertex INT_VAR width_total offset=ent_off+0x20 END
         LPF flip_orientation INT_VAR offset=0x24+ent_off END
      END
      // flip containers
      GET_OFFSET_ARRAY cont_arr ARE_V10_CONTAINERS
      PHP_EACH cont_arr AS ind=>cont_off BEGIN
         LPF flip_vertex INT_VAR width_total offset=cont_off+0x20 END
         LPF flip_vertex INT_VAR width_total offset=cont_off+0x34 END
         LPF flip_bounding_box INT_VAR layout=2 width_total offset=cont_off+0x38 END
         READ_LONG cont_off+0x50 initial_vertex_index
         READ_LONG cont_off+0x54 vertex_number
         LPF invert_vertex_sequence_order INT_VAR initial_vertex_offset=vert_off initial_vertex_index vertex_number width_total END
      END
      // flip ambients
      GET_OFFSET_ARRAY amb_arr ARE_V10_AMBIENTS
      PHP_EACH amb_arr AS ind=>amb_off BEGIN
         LPF flip_vertex INT_VAR width_total offset=amb_off+0x20 END
      END
      // flip doors
      GET_OFFSET_ARRAY door_arr ARE_V10_DOORS
      PHP_EACH door_arr AS ind=>door_off BEGIN
         LPF flip_vertex INT_VAR width_total offset=door_off+0x74 END
         LPF flip_vertex INT_VAR width_total offset=door_off+0x90 END
         LPF flip_vertex INT_VAR width_total offset=door_off+0x94 END
         LPF flip_bounding_box INT_VAR layout=2 width_total offset=door_off+0x38 END
         LPF flip_bounding_box INT_VAR layout=2 width_total offset=door_off+0x40 END
         READ_LONG door_off+0x2c initial_vertex_index
         READ_SHORT door_off+0x30 vertex_number
         LPF invert_vertex_sequence_order INT_VAR initial_vertex_offset=vert_off initial_vertex_index vertex_number width_total END
         READ_LONG door_off+0x34 initial_vertex_index
         READ_SHORT door_off+0x32 vertex_number
         LPF invert_vertex_sequence_order INT_VAR initial_vertex_offset=vert_off initial_vertex_index vertex_number width_total END
         READ_LONG door_off+0x48 initial_vertex_index
         READ_SHORT door_off+0x4c vertex_number
         LPF invert_vertex_sequence_order INT_VAR is_searchmap=1 initial_vertex_offset=vert_off initial_vertex_index vertex_number width_total END
         READ_LONG door_off+0x50 initial_vertex_index
         READ_SHORT door_off+0x4e vertex_number
         LPF invert_vertex_sequence_order INT_VAR is_searchmap=1 initial_vertex_offset=vert_off initial_vertex_index vertex_number width_total END

      END
      // flip animations
      GET_OFFSET_ARRAY anim_arr ARE_V10_ANIMATIONS
      PHP_EACH anim_arr AS ind=>anim_off BEGIN
         LPF flip_vertex INT_VAR width_total offset=anim_off+0x20 END
      END
      // flip automap notes
      GET_OFFSET_ARRAY auto_arr 0xc4 4 0xc8 4 0 0 0x34
      PHP_EACH auto_arr AS ind=>auto_off BEGIN
         LPF flip_vertex INT_VAR width_total offset=auto_off END
      END
   BUT_ONLY
   // copy over the inverted files

   COPY "%file_loc%/%area%sr.bmp" override
   COPY "%file_loc%/%area%ht.bmp" override
   COPY "%file_loc%/%area%lm.bmp" override

   ACTION_IF FILE_EXISTS_IN_GAME "%file_loc%/%area%ln.bmp" THEN BEGIN
       COPY "%file_loc%/%area%ln.bmp" override
   END

   ACTION_IF GAME_IS "bg2ee iwdee eet bgee" BEGIN
	  COPY "%file_loc%/%area%.tis" override
      COPY "%file_loc%/%area%N.tis" override IF_EXISTS
      ACTION_BASH_FOR "%file_loc%" ".*\.pvrz" BEGIN
         COPY "%BASH_FOR_FILESPEC%" override
      END
   END ELSE BEGIN
      COPY "%file_loc%/%area%v.tis" "override/%area%.tis"
      COPY "%file_loc%/%area%vn.tis" "override/%area%n.tis" IF_EXISTS
   END
   
   // invert any scripts
   ACTION_IF "%script_array%" STRING_COMPARE "" BEGIN
      ACTION_PHP_EACH "%script_array%" AS script=>discard BEGIN
         COPY_EXISTING "%script%.bcs" override
               DECOMPILE_AND_PATCH BEGIN
                  REPLACE_EVALUATE "\[\([0-9]+\)\.\([0-9]+\)\],\([NSEW]\)+)" BEGIN
                     SET xnew=width_total - "%MATCH1%"
                     SET ynew="%MATCH2%"
                     INNER_PATCH_SAVE orientation "%MATCH3%" BEGIN
                        REPLACE_TEXTUALLY E Q
                        REPLACE_TEXTUALLY W E
                        REPLACE_TEXTUALLY Q W
                     END
                  END
                  "[%xnew%.%ynew%],%orientation%)"
               END
         BUT_ONLY
      END
   END





END

//////////////////////////////////////////
/// Take a tile and flip its index L-R
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION flip_tile
  INT_VAR height=0
          width=0
          tile_number=0
  RET new_number
BEGIN
  base = (tile_number / width ) * width
  residue = tile_number - base
  residue = (width - 1) - residue
  new_number = base + residue
END


//////////////////////////////////////////
/// Take an orientation and flip it L-R
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION flip_orientation
  INT_VAR offset=0
BEGIN
  WRITE_SHORT offset (0x10 - SHORT_AT offset)
END


//////////////////////////////////////////
/// Take a vertex and flip it L/R
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION flip_vertex
  INT_VAR width_total=0
          offset=0
		  is_searchmap=0
BEGIN
  PATCH_IF is_searchmap BEGIN
	width_total = (width_total * 4) / 64
  END
  PATCH_IF SHORT_AT offset>=0 BEGIN
     WRITE_SHORT offset (width_total - SHORT_AT offset)
  END
END

//////////////////////////////////////////
/// Take a bounding box and flip it L/R
///
/// Multiple layouts. 1=LRTB, 2=LTRB
///
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION flip_bounding_box
  INT_VAR width_total=0
          offset=0
          layout=0
BEGIN
  PATCH_MATCH "%layout%" WITH
  1 BEGIN step=2 END
  2 BEGIN step=4 END
  DEFAULT
     PATCH_FAIL "unknown bounding box layout"
  END
  READ_SHORT offset left
  READ_SHORT (offset+step) right
  WRITE_SHORT offset (width_total - right)
  WRITE_SHORT (offset+step) (width_total - left)
END

//////////////////////////////////////////
/// Take the sequence of vertices defining a polygon.
/// Flip each element, then reverse the order, from
/// 0 1 2 3 ... N to 0 N ... 3 2 1
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION invert_vertex_sequence_order
  INT_VAR initial_vertex_offset=0
          initial_vertex_index=0
          vertex_number=0
          width_total=0
		  is_searchmap=0
BEGIN
  // flip individual elements
  FOR (n=0;n<vertex_number;n+=1) BEGIN
     LPF flip_vertex INT_VAR is_searchmap width_total offset=initial_vertex_offset + 4*(initial_vertex_index + n) END
  END
  // do the inversion
  PATCH_IF vertex_number>2 BEGIN
  data_length = (vertex_number - 1)*4
  READ_ASCII initial_vertex_offset + 4*(initial_vertex_index + 1) data (data_length)
  LPF invert_string INT_VAR block_size=4 STR_VAR string="%data%" RET data_new=string END
  WRITE_ASCIIE initial_vertex_offset + 4*(initial_vertex_index + 1) "%data_new%"
  END
END

//////////////////////////////////////////
/// Take a string of M x N elements, treat
/// it as M N-element-long substrings,
/// and invert it
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION invert_string
    INT_VAR block_size=0
    STR_VAR string=""
    RET string
BEGIN
    SET number=(STRING_LENGTH "%string%") / block_size
    SPRINT string_old "%string%"
    SPRINT string ""
    INNER_PATCH "%string_old%" BEGIN
      FOR (n=0;n<number;n+=1) BEGIN
          SET index=n*block_size
          READ_ASCII index data (block_size)
          SPRINT string "%data%"^"%string%"
      END
    END
END

DEFINE_ACTION_FUNCTION invert_string
   INT_VAR block_size=0
   STR_VAR string=""
   RET string
BEGIN
   OUTER_INNER_PATCH "" BEGIN
      LPF invert_string INT_VAR block_size STR_VAR string RET string END
   END
END


////////////////////////////////////////////////
//  Truncate the line defining a hovering wall
//  baseline
////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION truncate_wall 
   INT_VAR xmin=0
           xmax=0
           ymin=0
           ymax=0
   STR_VAR vertices=""
   RET vertices
       in_bounds
BEGIN
   // get the data
   INNER_PATCH "%vertices%" BEGIN
      READ_SHORT 0x0 x1
      READ_SHORT 0x2 y1
      READ_SHORT 0x4 x2
      READ_SHORT 0x6 y2
   END
   // are they in bounds?
   LPF point_in_bounds INT_VAR x=x1 y=y1 xmin xmax ymin ymax RET in_bounds_1=in_bounds END
   LPF point_in_bounds INT_VAR x=x2 y=y2 xmin xmax ymin ymax RET in_bounds_2=in_bounds END
   // if both are in bounds, we're done
   PATCH_IF in_bounds_1 && in_bounds_2 BEGIN
        x1_out=x1
        x2_out=x2
        y1_out=y1
        y2_out=y2
        in_bounds=1
   END ELSE
   PATCH_IF in_bounds_1 BEGIN // if 1 is in bounds, new point 2 is the crossing point to old point 2
        x1_out=x1
        y1_out=y1
       LPF find_crossing_points INT_VAR x1 y1 x2 y2 xmin xmax ymin ymax RET x2_out=xcross1 y2_out=ycross1 END
       in_bounds=1
   END ELSE
   PATCH_IF in_bounds_2 BEGIN // if 2 is in bounds, new point 1 is the crossing point from old point 1
       LPF find_crossing_points INT_VAR x1 y1 x2 y2 xmin xmax ymin ymax RET x1_out=xcross1 y1_out=ycross1 END
        x2_out=x2
        y2_out=y2
       in_bounds=1
   END ELSE BEGIN // if neither is in bounds, some part of the line joining them *might* be in bounds, in which case the two crossing points define the new line
                  // (this is a bit of an edge case, as the line would span the entire cropped region)
       LPF find_crossing_points INT_VAR x1 y1 x2 y2 xmin xmax ymin ymax RET x1_out=xcross1 y1_out=ycross1 x2_out=xcross2 y2_out=ycross2 END
       in_bounds = (x1_out>0)
   END
   PATCH_IF in_bounds BEGIN
      INNER_PATCH_SAVE vertices "XXXXXXXX" BEGIN
          WRITE_SHORT 0x0 x1_out
          WRITE_SHORT 0x2 y1_out
          WRITE_SHORT 0x4 x2_out
          WRITE_SHORT 0x6 y2_out
      END
   END
END



/*

Truncate a polygon onto a rectangle (and also return its bounding box)

This is a non-trivial mathematical problem. Naive solutions end up getting confused when corners get cut off, or
when a line between two points crosses the boundary twice.

Here's my solution:

- work through consecutive pairs (P1,P2), copying them to a new file
Step 1:
- if P1 is inside, add it
- if P1 is outside, and in a face region (i.e. in bounds one way but not another, add a placeholder token (a 4-character string, 'xmin','ymax' etc)
- if P1 is outside, and in a corner region (i.e. out of bounds in both ways) add the appropriate corner
Step 2:
- add any crossing point(s) between P1 and P2

Then go through again. Any transitions between faces get replaced by the associated corner

To complicate matters, polygons *mostly* need to be listed with the highest-y-value (i.e. lowest) point first. 
But this is not *always* true, and sometimes forcing the order breaks the polygon. What the actual rule is, I don't know,
despite an afternoon's research.

So: the plan is, ain't broke don't fix. *If* the first polygon obeys the rule, *and* it gets truncated, then we'll reorder. Otherwise, not.

This generates duplicates, so deduplicate it at the end.
*/

DEFINE_PATCH_FUNCTION truncate_polygon
   INT_VAR xmax=0
           ymax=0
           xmin=0
           ymin=0
		   bb_ymax=0
   STR_VAR vertices=""
   RET vertices
       bb_xmin
       bb_xmax
       bb_ymin
       bb_ymax
BEGIN
   // initialise
   SPRINT vertices_old "%vertices%"
   SPRINT vertices ""
   SET bb_xmin=99999
   SET bb_xmax=0
   SET bb_ymin=99999
   SET bb_ymax=0
   SET count=(STRING_LENGTH "%vertices_old%") / 4
   // check if we need to reorder
   LPF get_vertex INT_VAR ind=0 STR_VAR vertices="%vertices_old%" RET x y END
   PATCH_IF y=bb_ymax BEGIN
       LPF find_quadrant INT_VAR x y xmin xmax ymin ymax RET quadrant END
	   PATCH_IF "%quadrant%" STRING_EQUAL_CASE null BEGIN
		   try_reordering=0
	   END ELSE BEGIN
	       try_reordering=1
	   END
   END ELSE BEGIN
       try_reordering=0
   END
   
   // start going through pairs
   SET ind=0
   WHILE ind<count BEGIN
        LPF get_vertex INT_VAR ind STR_VAR vertices="%vertices_old%" RET xlast=x ylast=y END
        SET next=ind+1
        SET next=next<count ? next : 0
        LPF get_vertex INT_VAR ind=next STR_VAR vertices="%vertices_old%" RET x y END
        // see if first point is in bounds
        LPF find_quadrant INT_VAR x=xlast y=ylast xmin xmax ymin ymax RET quadrant END
        PATCH_MATCH "%quadrant%" WITH
        null BEGIN // in bounds: add it
             LPF append_to_vertices INT_VAR x=xlast y=ylast STR_VAR vertices RET vertices END
             LPF update_bb INT_VAR x=xlast y=ylast bb_xmin bb_xmax bb_ymin bb_ymax RET bb_xmin bb_xmax bb_ymin bb_ymax END
        END
        DEFAULT
             SPRINT vertices "%vertices%"^"%quadrant%"
        END
        // now check for crossing points and add them
        LPF find_crossing_points INT_VAR xmax xmin ymax ymin x1=xlast y1=ylast x2=x y2=y RET xcross1 ycross1 xcross2 ycross2 END
        PATCH_IF xcross1>=0 BEGIN
             LPF append_to_vertices INT_VAR x=xcross1 y=ycross1 STR_VAR vertices RET vertices END
             LPF update_bb INT_VAR x=xcross1 y=ycross1 bb_xmin bb_xmax bb_ymin bb_ymax RET bb_xmin bb_xmax bb_ymin bb_ymax END
        END
        PATCH_IF xcross2>=0 BEGIN
             LPF append_to_vertices INT_VAR x=xcross2 y=ycross2 STR_VAR vertices RET vertices END
             LPF update_bb INT_VAR x=xcross2 y=ycross2 bb_xmin bb_xmax bb_ymin bb_ymax RET bb_xmin bb_xmax bb_ymin bb_ymax END
        END
        ind +=1
   END // end of main WHILE loop
   // to handle cyclical cases, append the last four bytes to the beginning, if it's an out-of-bounds point
   INNER_PATCH_SAVE vertices "%vertices%" BEGIN
        READ_ASCII 0x0 first (4)
        READ_ASCII (BUFFER_LENGTH - 4) last (4)
        PATCH_MATCH "%first%" WITH
        xmin xmax ymin ymax BEGIN
        END
        DEFAULT
           SPRINT first ""
        END
   END
   SPRINT vertices "%vertices%"^"%first%"
   // compress direction changes into corners
   INNER_PATCH_SAVE vertices "%vertices%" BEGIN
      REPLACE_TEXTUALLY "xmaxymax" xypp
      REPLACE_TEXTUALLY "ymaxxmax" xypp
      REPLACE_TEXTUALLY "xminymax" xymp
      REPLACE_TEXTUALLY "ymaxxmin" xymp
      REPLACE_TEXTUALLY "xmaxymin" xypm
      REPLACE_TEXTUALLY "yminxmax" xypm
      REPLACE_TEXTUALLY "xminymin" xymm
      REPLACE_TEXTUALLY "yminxmin" xymm
   END
   // work out corner code
   INNER_PATCH_SAVE xymm xxxx BEGIN
      WRITE_SHORT 0x0 xmin
      WRITE_SHORT 0x2 ymin
   END
   INNER_PATCH_SAVE xypm xxxx BEGIN
      WRITE_SHORT 0x0 xmax
      WRITE_SHORT 0x2 ymin
   END
   INNER_PATCH_SAVE xymp xxxx BEGIN
      WRITE_SHORT 0x0 xmin
      WRITE_SHORT 0x2 ymax
   END
   INNER_PATCH_SAVE xypp xxxx BEGIN
      WRITE_SHORT 0x0 xmax
      WRITE_SHORT 0x2 ymax
   END
   // substitute them in and remove any residual entries
   INNER_PATCH_SAVE vertices "%vertices%" BEGIN

      PATCH_FOR_EACH var IN xymm xymp xypm xypp BEGIN
         SPRINT val EVAL "%%var%%"
         REPLACE_TEXTUALLY "%var%" "%val%"
      END
      PATCH_FOR_EACH var IN xmin xmax ymin ymax BEGIN
         REPLACE_TEXTUALLY "%var%" ""
      END
   END
   // get rid of duplicates
   LPF deduplicate_vertices STR_VAR vertices RET vertices END
   PATCH_IF try_reordering BEGIN
      LPF order_wall_vertices STR_VAR vertices RET vertices END
   END
END


DEFINE_PATCH_FUNCTION update_bb 
     INT_VAR x=0 
             y=0
             bb_xmin=0 
             bb_xmax=0
             bb_ymin=0 
             bb_ymax=0
     RET bb_xmin bb_xmax bb_ymin bb_ymax 
BEGIN
     bb_xmin=(bb_xmin<x)? bb_xmin : x
     bb_xmax=(bb_xmax>x)? bb_xmax : x
     bb_ymin=(bb_ymin<y)? bb_ymin : y
     bb_ymax=(bb_ymax>y)? bb_ymax : y
END

DEFINE_PATCH_FUNCTION append_to_vertices
    INT_VAR x=0
            y=0
    STR_VAR vertices=""
    RET vertices
BEGIN
    INNER_PATCH_SAVE vertices "%vertices%" BEGIN
       SET insert_point=BUFFER_LENGTH
       INSERT_BYTES insert_point 4
       WRITE_SHORT insert_point x
       WRITE_SHORT (insert_point+2) y
    END
END

DEFINE_PATCH_FUNCTION get_vertex
    INT_VAR ind=0
    STR_VAR vertices=""
    RET x y
BEGIN
    INNER_PATCH  "%vertices%" BEGIN
       READ_SHORT (4*ind) x
       READ_SHORT (4*ind)+2 y
    END
END

DEFINE_PATCH_FUNCTION deduplicate_vertices
     STR_VAR vertices=""
     RET vertices
BEGIN
   INNER_PATCH_SAVE vertices "%vertices%" BEGIN
    PATCH_IF BUFFER_LENGTH >=8 BEGIN
      SET insert_point=4
      READ_ASCII 0x0 datalast (4)
      SET length=BUFFER_LENGTH
      WHILE insert_point<length BEGIN
          READ_ASCII insert_point data (4)
          PATCH_IF "%data%" STRING_EQUAL "%datalast%" BEGIN
             DELETE_BYTES insert_point 4
             SET length -=4
          END ELSE BEGIN
             SPRINT datalast "%data%"
             SET insert_point +=4
          END
      END
    END
   END
END

///////////////////////////////////////////////
//  A wall polygon needs to start with the lowest
// (=largest y value) term.
//
//  If there are two points that share a lowest
//  value, I think they need to be the sequential.
// Normally that will occur automatically, but we need
// to allow for the first and last being joint lowest
///////////////////////////////////////////////

DEFINE_PATCH_FUNCTION order_wall_vertices
     STR_VAR vertices=""
     RET vertices
BEGIN
     count = (STRING_LENGTH "%vertices%")/4
     // get the data
     SET ymax=0
 //    SET xmax=0
     SET ind_start=0
     FOR (ind=0;ind<count;ind+=1) BEGIN
          LPF get_vertex INT_VAR ind STR_VAR vertices RET x y END
          PATCH_IF (y>ymax ) BEGIN
             SET ymax=y
          //   SET xmax=x
             SET ind_start=ind
          END
     END
     PATCH_IF ind_start>0 BEGIN
        INNER_PATCH_SAVE vertices "%vertices%" BEGIN
           SET length=ind_start * 4
           READ_ASCII 0x0 data (length)
           DELETE_BYTES 0x0 length
        END
        SPRINT vertices "%vertices%"^"%data%"
     END
     // now deal with that edge case
     INNER_PATCH_SAVE vertices "%vertices%" BEGIN
       READ_SHORT 0x2 y_first
       READ_SHORT (BUFFER_LENGTH - 0x2) y_last
       PATCH_IF y_last=y_first BEGIN
          READ_ASCII (BUFFER_LENGTH - 0x4) last_vertex (4)
          DELETE_BYTES (BUFFER_LENGTH - 0x4) 4
          INSERT_BYTES 0x0 4
          WRITE_ASCIIE 0x0 "%last_vertex%"
       END
     END
END



//////////////////////////////////////////
/// Assess whether a given (x,y) pair is
/// in or out of bounds.
///
/// Also return where it is if out of bounds
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION point_in_bounds
   INT_VAR x=0
           xmin=0
           xmax=0
           y=0
           ymin=0
           ymax=0
   RET in_bounds
       x_in_bounds
       y_in_bounds
BEGIN
   x_in_bounds=(x>=xmin && x<=xmax ? 1 : 0) || (x<0)
   y_in_bounds=(y>=ymin && y<=ymax ? 1 : 0) || (y<0)
   in_bounds = x_in_bounds * y_in_bounds
END


//////////////////////////////////////////
/// Check if two rectangles overlap
//////////////////////////////////////////

DEFINE_PATCH_FUNCTION rectangle_overlap 
   INT_VAR xmin_1=0
           xmax_1=0
           ymin_1=0
           ymax_1=0
           xmin_2=0
           xmax_2=0
           ymin_2=0
           ymax_2=0
   RET overlap
BEGIN
   LPF point_in_bounds INT_VAR x=xmin_1 y=ymin_1 xmin=xmin_2 xmax=xmax_2 ymin=ymin_2 ymax=ymax_2 RET in_bounds_1=in_bounds END
   LPF point_in_bounds INT_VAR x=xmin_1 y=ymax_1 xmin=xmin_2 xmax=xmax_2 ymin=ymin_2 ymax=ymax_2 RET in_bounds_2=in_bounds END
   LPF point_in_bounds INT_VAR x=xmax_1 y=ymin_1 xmin=xmin_2 xmax=xmax_2 ymin=ymin_2 ymax=ymax_2 RET in_bounds_3=in_bounds END
   LPF point_in_bounds INT_VAR x=xmax_1 y=ymax_1 xmin=xmin_2 xmax=xmax_2 ymin=ymin_2 ymax=ymax_2 RET in_bounds_4=in_bounds END
   SET overlap = in_bounds_1 || in_bounds_2 || in_bounds_3 || in_bounds_4
END

//////////////////////////////////////////
/// Find what quadrant a point is in
//////////////////////////////////////////


DEFINE_PATCH_FUNCTION find_quadrant
   INT_VAR x=0
           xmin=0
           xmax=0
           y=0
           ymin=0
           ymax=0
   RET  quadrant
BEGIN
   PATCH_IF (y<ymin) BEGIN
      PATCH_IF x<xmin BEGIN
         SPRINT quadrant "xymm"
      END ELSE
      PATCH_IF (x>xmax) BEGIN
         SPRINT quadrant "xypm"
      END ELSE BEGIN
         SPRINT quadrant ymin
      END
   END ELSE
   PATCH_IF (y>ymax) BEGIN
      PATCH_IF x<xmin BEGIN
         SPRINT quadrant "xymp"
      END ELSE
      PATCH_IF (x>xmax) BEGIN
         SPRINT quadrant "xypp"
      END ELSE BEGIN
         SPRINT quadrant ymax
      END
   END ELSE BEGIN
      PATCH_IF x<xmin BEGIN
         SPRINT quadrant xmin
      END ELSE
      PATCH_IF (x>xmax) BEGIN
         SPRINT quadrant xmax
      END ELSE BEGIN
         SPRINT quadrant null
      END
   END
END


DEFINE_ACTION_FUNCTION point_in_bounds
   INT_VAR x=0
           xmin=0
           xmax=0
           y=0
           ymin=0
           ymax=0
   RET in_bounds
       x_in_bounds
       y_in_bounds
BEGIN
   OUTER_INNER_PATCH "" BEGIN
      LPF point_in_bounds
          INT_VAR x xmin xmax y ymin ymax 
          RET in_bounds x_in_bounds y_in_bounds
      END
   END
END

////////////////////////////////////////////////////
///  Function to find when there is a crossing point
///  on a boundary between two points. If there are 
///  two, return the closest one to the first point
////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION find_crossing_points
    INT_VAR x1=0
            x2=0
            y1=0
            y2=0
            xmin=0
            xmax=0
            ymin=0
            ymax=0
    RET xcross1
        ycross1
        xcross2
        ycross2
BEGIN
      // find the four crossing points
      LPF l_r_crossing_point INT_VAR x1 x2 y1 y2 bdy=xmin RET cr_x_1=xcross cr_y_1=ycross END
      LPF l_r_crossing_point INT_VAR x1 x2 y1 y2 bdy=xmax RET cr_x_2=xcross cr_y_2=ycross END
      LPF u_d_crossing_point INT_VAR x1 x2 y1 y2 bdy=ymin RET cr_x_3=xcross cr_y_3=ycross END
      LPF u_d_crossing_point INT_VAR x1 x2 y1 y2 bdy=ymax RET cr_x_4=xcross cr_y_4=ycross END
      // check if they're in bounds and, if so, work out their x^2-distance from the first point
      xcross1="-1"
      ycross1="-1"
      xcross2="-1"
      ycross2="-1"
      score=99999
      FOR (i=1;i<=4;i+=1) BEGIN
         x=$cr_x("%i%")
         y=$cr_y("%i%")
         LPF point_in_bounds INT_VAR x y xmin xmax ymin ymax RET in_bounds END
         PATCH_IF in_bounds BEGIN
            this_score=(x - x1)*(x - x1)
            PATCH_IF this_score<score BEGIN
               score=this_score
               xcross2=xcross1
               ycross2=ycross1
               xcross1=x
               ycross1=y
            END ELSE BEGIN
               xcross2=x
               ycross2=y
            END
         END
      END
END


////////////////////////////////////////////////////
///  Function to find when the line between 
/// two points crosses the vertical line x=bdy
////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION l_r_crossing_point
    INT_VAR x1=0
            x2=0
            y1=0
            y2=0
            bdy=0
    RET xcross
        ycross
BEGIN
    SET exists=1
    PATCH_IF x1>bdy BEGIN
       PATCH_IF x2>bdy BEGIN
          SET exists=0 // if both on RHS, no crossing
       END ELSE BEGIN // swap over, so (x1,y1) on LHS
          SET xtemp=x1
          SET ytemp=y1
          SET x1=x2
          SET y1=y2
          SET x2=xtemp
          SET y2=ytemp
       END
    END ELSE BEGIN
       PATCH_IF x2<bdy BEGIN
          SET exists=0 // if both on LHS, no crossing
       END
    END
    PATCH_IF x1=bdy || x2=bdy BEGIN
       SET exists=0
    END
    PATCH_IF exists BEGIN
          SET xcross = bdy
          SET ycross = y1 + ((xcross - x1) * (y2 - y1))/(x2 - x1)
    END ELSE BEGIN
          SET xcross = "-1"
          SET ycross = "-1"
    END
END

////////////////////////////////////////////////////
///  Function to find when the line between 
/// two points crosses the horizontal line y=bdy
////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION u_d_crossing_point
    INT_VAR x1=0
            x2=0
            y1=0
            y2=0
            bdy=0
    RET xcross
        ycross
BEGIN
    // I've had trouble sometimes directly mixing variables in a function arg so play it safe
    x1_ =y1
    x2_ =y2
    y1_ =x1
    y2_ =x2
    LPF l_r_crossing_point INT_VAR x1=x1_ x2=x2_ y1=y1_ y2=y2_ bdy RET xcross_=xcross ycross_=ycross END
    xcross=ycross_
    ycross=xcross_
END

////////////////////////////////////////////////////
///  Truncate a bitmap (search map, etc)
///
///  These are uncompressed grids of data in 4-bit
///  per-pixel encoding (see IESDP), or 8-bit
///  for the light map. Note that the
///  bitmaps are stretched vertically compared to
///  the displayed areas. There are 4 pixels per
///  tile horizontally, 4*4/3 pixels per tile 
///  vertically
///
///  data begins at 0x36 +4* num_colors goes from the bottom
///  left corner, not top left as per BG conventions
///
///  A complication is that in the uncompressed BMP format,
///  data rows must be multiples of 4 bytes. That means that
///  for the 4-bits-per-pixel maps (HT and SR), if xlen is
///  an odd number the rows need to be null-padded.
////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION search_map_truncate
   INT_VAR x=0
           y=0
           xlen=0
           ylen=0
   STR_VAR type=""
BEGIN
 READ_LONG 0x1e compression
 PATCH_IF compression=0 BEGIN
   READ_SHORT 0x1c bitcount
   PATCH_MATCH "%bitcount%" WITH
   4 BEGIN
       multiplier=1
       divisor=2
       num_colors=16
   END
   8 BEGIN
       multiplier=1
       divisor=1
       num_colors=256
   END
   24 BEGIN
       multiplier=4
       divisor=1
       num_colors=0
   END
   DEFAULT
      PATCH_FAIL "%bitcount% is not a recognised bitcount"
   END
   xmin=x*4
   xmax=(x+xlen)*4
   ymin=(y*16)/3
   ymax=((y+ylen)*16)/3
   offset_base=0x36 + 4* num_colors
   READ_LONG 0x12 width
   READ_LONG 0x16 height


   rowsize=width * multiplier / divisor
   rowsize_round_down = ((rowsize /4) * 4 )
   PATCH_IF !(rowsize_round_down=rowsize) BEGIN
      rowsize=rowsize_round_down + 4
   END

   // file size sanity check
   raster_size=rowsize * height
   actual_size=BUFFER_LENGTH
   est_size=raster_size+offset_base
   diff=est_size - actual_size
   PATCH_IF ! (diff=0) BEGIN
      PATCH_PRINT "offset was calculated as %offset_base%; raster was calculated as %raster_size%"
      PATCH_PRINT "%offset_base%+%raster_size%=%est_size%; actual size is %actual_size%"
      PATCH_PRINT "Difference is %diff%"
      PATCH_IF diff>0 BEGIN 
         PATCH_PRINT "attempting to fix by zero-padding"
         insert_point=actual_size
         INSERT_BYTES insert_point diff
         WHILE insert_point<est_size BEGIN
              WRITE_BYTE insert_point 0
              insert_point +=1
         END
      END ELSE BEGIN
         PATCH_WARN "Actual file is too large; install will probably fail hard."
      END
   END

   SPRINT raster_new ""
   // fill the raster row by row
   width_new=(xmax - xmin)
   height_new=0
   FOR (ind=0;ind<height;ind +=1) BEGIN
      READ_ASCII offset_base +(height - ind - 1)*rowsize row (rowsize)
      LPF truncate_bitmap_row INT_VAR row_num=ind xmin xmax ymin ymax divisor STR_VAR row RET row_out row_empty END
      SPRINT raster_new "%row_out%"^"%raster_new%"
      PATCH_IF !row_empty BEGIN
         height_new +=1
      END
   END
   // insert the new raster

   DELETE_BYTES offset_base (BUFFER_LENGTH - offset_base)
   INSERT_BYTES offset_base (STRING_LENGTH "%raster_new%")
   WRITE_ASCII offset_base "%raster_new%"

   // update details
   WRITE_LONG 0x12 width_new
   WRITE_LONG 0x16 height_new
   WRITE_LONG 0x22 ((width_new * height_new * multiplier) / divisor )
 END ELSE BEGIN
    PATCH_WARN "cannot automatically truncate '%SOURCE_FILE%' bitmap as it is compressed"
 END
END

   
DEFINE_PATCH_FUNCTION truncate_bitmap_row
    INT_VAR row_num=0 xmin=0 ymin=0 xmax=0 ymax=0 divisor=0
    STR_VAR row=""
    RET row_out row_empty
BEGIN
    PATCH_IF ((row_num<ymin) || (row_num >= ymax) ) BEGIN
       SPRINT row_out ""
       row_empty=1
    END ELSE BEGIN
       SET length=((xmax - xmin) * multiplier )/ divisor
       INNER_PATCH "%row%" BEGIN
          DELETE_BYTES 0x0 ((xmin * multiplier) / divisor)
          READ_ASCII 0x0 row_out (length)
       END
       length_round_down = (length / 4) * 4
       PATCH_IF length=length_round_down BEGIN
          length_round_up=length
       END ELSE BEGIN
          length_round_up=length_round_down + 4
       END
       pad = length_round_up - length
       PATCH_IF pad>0 BEGIN
          INNER_PATCH_SAVE row_out "%row_out%" BEGIN
             insert_point=BUFFER_LENGTH
             INSERT_BYTES insert_point pad
             FOR (i=0;i<pad;i+=1) BEGIN
                WRITE_BYTE (insert_point + i) 0
             END
          END
       END
       row_empty=0
    END
END

//////////////////////////////////////////
/// Crop an area file of all out-of-bounds
/// elements
///
/// Requires SFO functionality
///////////////////////////////////////////

DEFINE_ACTION_FUNCTION crop_are_file
    INT_VAR x=0 y=0 xlen=0 ylen=0
    STR_VAR area=""
BEGIN
   OUTER_SET xmin=x*0x40
   OUTER_SET ymin=y*0x40
   OUTER_SET xmax=(x+xlen)*0x40
   OUTER_SET ymax=(y+ylen)*0x40
   ACTION_DEFINE_ASSOCIATIVE_ARRAY all_deletes BEGIN
      delete_actor=>actor_out_of_bounds
      delete_trigger=>trigger_out_of_bounds
      delete_mapnote=>mapnote_out_of_bounds
      delete_container=>container_out_of_bounds
      delete_door=>door_out_of_bounds
      delete_entrance=>generic_out_of_bounds
      delete_animation=>generic_out_of_bounds
      delete_ambient=>generic_out_of_bounds
      delete_spawn=>generic_out_of_bounds
   END
   LAF edit_area STR_VAR area edits=all_deletes END
   ACTION_DEFINE_ASSOCIATIVE_ARRAY actor_shift BEGIN
      actor_x_coord_start=>~actor_x_coord_start in slide_x~
      actor_y_coord_start=>~actor_y_coord_start in slide_y~
      actor_x_coord_dest=>~actor_x_coord_dest in slide_x~
      actor_y_coord_dest=>~actor_y_coord_dest in slide_y~
   END
   ACTION_DEFINE_ASSOCIATIVE_ARRAY mapnote_shift BEGIN
      mapnote_xloc =>~mapnote_xloc in slide_x~
      mapnote_yloc =>~mapnote_yloc in slide_y~
   END
   ACTION_DEFINE_ASSOCIATIVE_ARRAY spawn_shift BEGIN
      spawn_xloc =>~spawn_xloc in slide_x~
      spawn_yloc =>~spawn_yloc in slide_y~
   END
   ACTION_DEFINE_ASSOCIATIVE_ARRAY entrance_shift BEGIN
      entrance_xloc =>~entrance_xloc in slide_x~
      entrance_yloc =>~entrance_yloc in slide_y~
   END
   ACTION_DEFINE_ASSOCIATIVE_ARRAY container_shift BEGIN
      container_xloc =>~container_xloc in slide_x~
      container_yloc =>~container_yloc in slide_y~
      container_trap_xloc =>~container_trap_xloc in slide_x~
      container_trap_yloc =>~container_trap_yloc in slide_y~
      container_top_left=>~container_top_left in slide_x~ // these are misnomers
      container_top_right=>~container_top_right in slide_y~ // these are misnomers
      container_bottom_right=>~container_bottom_right in slide_x~ // these are misnomers
      container_bottom_left=>~container_bottom_left in slide_y~ // these are misnomers
   END
   ACTION_DEFINE_ASSOCIATIVE_ARRAY ambient_shift BEGIN
      ambient_xloc =>~ambient_xloc in slide_x~
      ambient_yloc =>~ambient_yloc in slide_y~
   END
   ACTION_DEFINE_ASSOCIATIVE_ARRAY animation_shift BEGIN
      animation_xloc =>~animation_xloc in slide_x~
      animation_yloc =>~animation_yloc in slide_y~
   END
   ACTION_DEFINE_ASSOCIATIVE_ARRAY vertex_shift BEGIN
      vertex_xloc =>~vertex_xloc in slide_x~
      vertex_yloc =>~vertex_yloc in slide_y~
   END
   ACTION_DEFINE_ASSOCIATIVE_ARRAY searchmap_vertex_shift BEGIN
      vertex_xloc =>~vertex_xloc in searchmap_slide_x~
      vertex_yloc =>~vertex_yloc in searchmap_slide_y~
   END
   ACTION_DEFINE_ASSOCIATIVE_ARRAY main_patch BEGIN
        patch_actor=>actor_shift 
        patch_mapnote=>mapnote_shift 
        patch_spawn=>spawn_shift 
        patch_entrance=>entrance_shift 
        patch_container=>container_shift 
        patch_ambient=>ambient_shift
        patch_animation=>animation_shift 
        patch_trigger_inline=>~slide_trigger=>null~ 
        patch_door_inline=>~slide_door=>null~
        patch_door_vertex_open=>vertex_shift
        patch_door_vertex_closed=>vertex_shift
        patch_door_vertex_open_impeded=>searchmap_vertex_shift
        patch_door_vertex_closed_impeded=>searchmap_vertex_shift
        patch_trigger_vertex=>vertex_shift
        patch_container_vertex=>vertex_shift


   END
   LAF edit_area STR_VAR area edits=main_patch END
END


///////////////////////////////////////////////////////////
//// Take a 4-bit spat out by Photoshop and remap
//// it to the standard 4-bit SR palette.  (Use L^2 distance
//// in color space if no exact match)
////
//// (I have tried to add 8bit=>4bit to this, but it's erratic
//// and not a priority to fix)
/////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION remap_search_map_colors
    STR_VAR map=""
            reference=""
            map_out=""
BEGIN

   // load in the target map colors
  COPY "%map%" override
   READ_SHORT 0x1c bitcount
   READ_LONG 0x0a data_off
   READ_LONG 0x2e colors_used
   PATCH_IF colors_used=0 BEGIN
      SET colors_used=0x10
   END
   FOR (ind=0;ind<colors_used;ind+=1) BEGIN
      offset=0x36 + 4*ind
      READ_BYTE offset red
      READ_BYTE offset+1 green
      READ_BYTE offset+2 blue
      SET $target_red("%ind%")=red
      SET $target_green("%ind%")=green
      SET $target_blue("%ind%")=blue
   END
  BUT_ONLY    
  COPY "%reference%" override
      FOR (ind=0;ind<0x36;ind +=2) BEGIN
         READ_LONG ind data
         SPRINT $data_old("%ind%") "%data%"
      END
   // load in the reference map colors
   FOR (ind=0;ind<0x10;ind+=1) BEGIN
      offset=0x36 + 4*ind
      READ_BYTE offset red
      READ_BYTE offset+1 green
      READ_BYTE offset+2 blue
      SET $reference_red("%ind%")=red
      SET $reference_green("%ind%")=green
      SET $reference_blue("%ind%")=blue
   END
   // get the whole color block
   READ_ASCII 0x36 color_block (0x40)
  BUT_ONLY
  // match the colors
  OUTER_FOR (i=0;i<colors_used;i+=1) BEGIN
     OUTER_SET target_red=$target_red("%i%")
     OUTER_SET target_green=$target_green("%i%")
     OUTER_SET target_blue=$target_blue("%i%")
     OUTER_SET distance_minimum="-1"
     OUTER_FOR (j=0;j<0x10;j+=1) BEGIN
       OUTER_SET reference_red=$reference_red("%j%")
       OUTER_SET reference_green=$reference_green("%j%")
       OUTER_SET reference_blue=$reference_blue("%j%")
       OUTER_SET distance=(target_red - reference_red)*(target_red - reference_red) + (target_green - reference_green)*(target_green - reference_green) + (target_blue - reference_blue)*(target_blue - reference_blue)
       PRINT "color %j%: distance=%distance%"
       ACTION_IF distance=0  BEGIN
          OUTER_SET $color_map("%i%")=j
          OUTER_SET distance_minimum=0
          PRINT "exact match: %i%=>%j%"
       END ELSE BEGIN
          ACTION_IF distance<distance_minimum || distance_minimum<0 BEGIN
             OUTER_SET distance_minimum=distance
             OUTER_SET nearest=j
          END
       END
     END
     ACTION_IF distance_minimum>0 BEGIN
        PRINT "nearest match for %i%: %nearest% (distance = %distance_minimum%)"
        OUTER_SET $color_map("%i%")=nearest
     END
  END


  // now go through the target data
  COPY "%map%" "%map_out%"
  // set type

  WRITE_SHORT 0x1c 4

  // insert space for new color block
      delta = 0x40 - 4* colors_used
      WRITE_SHORT 0x2 (SHORT_AT 0x2 + delta)
      WRITE_LONG 0xa (LONG_AT 0xa + delta)
      DELETE_BYTES 0x36 (4*colors_used)
      INSERT_BYTES 0x36 0x40

      WRITE_LONG 0x2e 16
      WRITE_LONG 0x32 16

      WRITE_ASCIIE 0x36 "%color_block%" (0x40)
      FOR (ind=0;ind<0x36;ind +=2) BEGIN
         READ_SHORT ind data
         SPRINT $data_new("%ind%") "%data%"
      END
      offset=0x76
      length=BUFFER_LENGTH
      WHILE offset<length BEGIN
       PATCH_IF bitcount=4 BEGIN
         READ_BYTE offset old
         first = old BAND 0b00001111
         second = ( old BAND 0b11110000 ) / 16
       END ELSE BEGIN
         READ_BYTE offset first
         READ_BYTE (offset+1) second
         DELETE_BYTES offset 1
         length = length - 1
       END
       PATCH_IF VARIABLE_IS_SET $color_map("%first%") BEGIN
            SET first_new=$color_map("%first%")
       END ELSE BEGIN
            SET first_new=1
       END
       PATCH_IF VARIABLE_IS_SET $color_map("%second%") BEGIN
            SET second_new=$color_map("%second%")
       END ELSE BEGIN
            SET second_new=1
       END
       new=second_new * 16 + first_new
       WRITE_BYTE offset new
       offset +=1
      END



END

//////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION swap_searchmap_code
    INT_VAR old=0
            new=0
    STR_VAR map=""
BEGIN
   OUTER_WHILE "%map%" STRING_COMPARE "" BEGIN
      LAF return_first_entry STR_VAR list="%map%" RET entry map=list END
      COPY_EXISTING "%entry%sr.bmp" override
           LPF swap_searchmap_code INT_VAR old new END
      BUT_ONLY
   END

END



DEFINE_PATCH_FUNCTION swap_searchmap_code
    INT_VAR old=0
            new=0
BEGIN
      READ_LONG 0xa offset_base
      FOR (offset=offset_base;offset<BUFFER_LENGTH;offset+=1) BEGIN
         READ_BYTE offset byte 
         first = byte BAND 0b00001111
         second = (byte BAND 0b11110000 ) /16
         first = (first=old)? new: first
         second = (second=old)? new: second
         byte_new = first + 16*second
         PATCH_IF !(byte_new=byte) BEGIN
            WRITE_BYTE offset byte_new
         END
      END
END



DEFINE_ACTION_FUNCTION build_wed
    INT_VAR width=0
            height=0
    STR_VAR tis=""
            wed=""
BEGIN
    COPY ".../stratagems-inline/blank" "override/%wed%.wed"
       // make sure it starts empty
       DELETE_BYTES 0x0 BUFFER_LENGTH
       INSERT_BYTES 0x0 0x20 // header
       WRITE_ASCII 0x0 "WED V1.3"
       WRITE_LONG 0x8 5 // # overlays
       WRITE_LONG 0x10 0x20 // overlay offset
       // insert first overlay
       INSERT_BYTES 0x20 0x18
       WRITE_SHORT 0x20 width
       WRITE_SHORT 0x22 height
       WRITE_ASCII 0x24 "%tis%" (8)
       INSERT_BYTES 0x38 0x60 // other overlays
       SET sec_header_off=0x98
       WRITE_LONG 0x14 sec_header_off
       INSERT_BYTES sec_header_off 0x14
       SET door_off=sec_header_off+0x14
       WRITE_LONG 0x18 door_off
       SET main_tilemap_off=door_off
       WRITE_LONG 0x30 main_tilemap_off
       FOR (i=0;i<width*height;i+=1) BEGIN
          SET this_tile_off=main_tilemap_off + 0xa * i
          INSERT_BYTES this_tile_off 0xa
          WRITE_SHORT this_tile_off i
          WRITE_SHORT (this_tile_off + 2) 1
          WRITE_SHORT (this_tile_off + 4) "-1"
       END
       SET other_tilemap_off=main_tilemap_off + width*height*0xa
       WRITE_LONG 0x48 other_tilemap_off
       WRITE_LONG 0x60 other_tilemap_off
       WRITE_LONG 0x78 other_tilemap_off
       WRITE_LONG 0x90 other_tilemap_off
       SET door_tile_ind_off=other_tilemap_off
       WRITE_LONG 0x1c door_tile_ind_off
       SET tile_lookup_off=door_tile_ind_off
       WRITE_LONG 0x34 tile_lookup_off
       FOR (i=0;i<width*height;i+=1) BEGIN
          SET this_off=tile_lookup_off + 0x2*i
          INSERT_BYTES this_off 2
          WRITE_SHORT this_off i
       END
       SET sec_tile_lookup_off=tile_lookup_off + 2 * width * height
       WRITE_LONG 0x4c other_tilemap_off
       WRITE_LONG 0x64 other_tilemap_off
       WRITE_LONG 0x7c other_tilemap_off
       WRITE_LONG 0x94 other_tilemap_off
       // find # wallgroups
       SET num_wallgroups = (width / 10) * ( (2* height) / 15)
       SET wallgroup_off=sec_tile_lookup_off
       WRITE_LONG 0xa4 wallgroup_off
       INSERT_BYTES wallgroup_off (0x4 * num_wallgroups)
       SET polygon_off = wallgroup_off + (0x4 * num_wallgroups)
       WRITE_LONG 0x9c polygon_off
       SET polygon_ind_off=polygon_off
       WRITE_LONG 0xa8 polygon_ind_off
       SET vertex_off=polygon_ind_off
       WRITE_LONG 0xa0 vertex_off





END

DEFINE_ACTION_FUNCTION get_polygons
    INT_VAR xmin=0
            xmax=0
            ymin=0
            ymax=0
    STR_VAR wed=""
            output_file=""
BEGIN
   COPY_EXISTING "%wed%.wed" override
     SPRINT output ""
     GET_OFFSET_ARRAY poly_arr 0x9c 4 0x98 4 0 0 0x12
     PHP_EACH poly_arr AS poly_ind=>poly_off BEGIN
        READ_SHORT 0xa+poly_off bb_l
        READ_SHORT 0xc+poly_off bb_r
        READ_SHORT 0xe+poly_off bb_t
        READ_SHORT 0x10+poly_off bb_b
        PATCH_IF (xmin<bb_r && xmax>bb_l && ymin<bb_t && ymax>bb_b) BEGIN
            SPRINT output "%output%%poly_ind% "
        END
     END
   BUT_ONLY
   LAF log_this STR_VAR file="%output_file%" input="%output%" END
END

DEFINE_ACTION_FUNCTION duplicate_area
	STR_VAR area_old=""
			area_new=""
BEGIN

	OUTER_INNER_PATCH_SAVE pvrz_old "%area_old%" BEGIN
		DELETE_BYTES 0x1 1
	END

	OUTER_INNER_PATCH_SAVE pvrz_new "%area_new%" BEGIN
		DELETE_BYTES 0x1 1
	END


	COPY_EXISTING "%area_old%.are" "override/%area_new%.are" 
		WRITE_ASCII 0x8 "%area_new%"
	
	COPY_EXISTING "%area_old%.wed" "override/%area_new%.wed"
		WRITE_ASCII 0x24 "%area_new%"
		
	COPY_EXISTING "%area_old%.tis" "override/%area_new%.tis"
	
	OUTER_FOR (ind=0;ind<100;ind+=1) BEGIN
		ACTION_IF ind<10 BEGIN
			OUTER_SPRINT digits "0%ind%"
		END ELSE BEGIN
			OUTER_SPRINT digits "%ind%"
		END
		ACTION_IF FILE_EXISTS_IN_GAME "%pvrz_old%%digits%.pvrz" BEGIN
			COPY_EXISTING "%pvrz_old%%digits%.pvrz" "override/%pvrz_new%%digits%.pvrz"
		END
	END

				  
	COPY_EXISTING 	"%area_old%sr.bmp" "override/%area_new%sr.bmp"			
					"%area_old%lm.bmp" "override/%area_new%lm.bmp"
					"%area_old%ht.bmp" "override/%area_new%ht.bmp"


END

///////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION add_wed_door 
	STR_VAR name=""
			tiles=""
BEGIN
	READ_LONG 0xc door_count
	READ_LONG 0x18 door_off
	READ_LONG 0x1c door_tilemap_lookup_off
	READ_LONG 0x9c wall_poly_off
	READ_LONG 0xa0 vertex_off
	READ_LONG 0xa4 wallgroup_off
	READ_LONG 0xa9 wall_poly_lookup_off
	READ_LONG 0x10 overlay_off
	READ_LONG 0x8 overlay_count
	
	// get tile data
	
	tile_count=0
	PATCH_CLEAR_ARRAY tile_data
	WHILE "%tiles%" STRING_COMPARE "" BEGIN
		LPF return_first_pair STR_VAR list="%tiles%" RET key value tiles=list END
		SPRINT $tile_data("%key%") "%value%"
		tile_count +=1
	END

	
	// clone last door
	
	READ_ASCII (door_off + 0x1a* (door_count - 1) ) data (0x1a)
	INSERT_BYTES (door_off + 0x1a*door_count) 0x1a
	WRITE_ASCIIE (door_off + 0x1a*door_count) "%data%"
	WRITE_ASCII (door_off + 0x1a*door_count)  "%name%" (8)
	READ_SHORT (door_off +0x1a*door_count + 0xc) last_tile_count
	READ_SHORT (door_off +0x1a*door_count + 0xa) last_tile_off
	new_tile_off=last_tile_off + last_tile_count
	WRITE_SHORT (door_off +0x1a*door_count + 0xa) new_tile_off
	WRITE_SHORT (door_off +0x1a*door_count + 0xc) tile_count
	WRITE_SHORT (door_off +0x1a*door_count + 0xe) 0
	WRITE_SHORT (door_off +0x1a*door_count + 0x10) 0
	
	
	delta= 0x1a

	// adjust main offsets (assumes doors are first)
	
	PATCH_FOR_EACH address IN 0x1c 0x9c 0xa0 0xa4 0xa8 BEGIN
	   WRITE_LONG address  ((LONG_AT address)+delta)
	END


	// adjust overlay offsets
	
	FOR (overlay_ind=0;overlay_ind<overlay_count;overlay_ind +=1) BEGIN
		offset=overlay_off + overlay_ind*0x18
		WRITE_LONG (offset+0x10) ((LONG_AT (offset+0x10)) + delta)
		WRITE_LONG (offset+0x14) ((LONG_AT (offset+0x14)) + delta)
	END
	
	// adjust door offsets

	FOR (door_ind=0;door_ind<door_count;door_ind +=1) BEGIN
		offset=door_off + door_ind*0x1a
		WRITE_LONG (offset+0x12) ((LONG_AT (offset+0x12)) + delta)
		WRITE_LONG (offset+0x16) ((LONG_AT (offset+0x16)) + delta)
	END
	
	// add 1 to door count
	
	door_count +=1
	WRITE_LONG 0xc door_count 

	
	delta2=2*tile_count // this is the extra-tiles delta
	
	door_tilemap_lookup_off +=delta
	offset=new_tile_off*2 + door_tilemap_lookup_off
	INSERT_BYTES offset 2*tile_count
	ind=0
	PHP_EACH tile_data AS tile=>discard BEGIN
		WRITE_SHORT offset+2*ind tile
		ind+=1
	END


	// adjust offsets again
	PATCH_FOR_EACH address IN 0x9c 0xa0 0xa4 0xa8 BEGIN
	   WRITE_LONG address  ((LONG_AT address)+delta2)
	END
	FOR (overlay_ind=0;overlay_ind<overlay_count;overlay_ind +=1) BEGIN
		offset=overlay_off + overlay_ind*0x18
		WRITE_LONG (offset+0x14) ((LONG_AT (offset+0x14)) + delta2)
	END
	FOR (door_ind=0;door_ind<door_count;door_ind +=1) BEGIN
		offset=door_off + door_ind*0x1a
		WRITE_LONG (offset+0x12) ((LONG_AT (offset+0x12)) + delta2)
		WRITE_LONG (offset+0x16) ((LONG_AT (offset+0x16)) + delta2)
	END
	
	// edit tiles
	
	READ_LONG 0x30 tilemap_off
	PHP_EACH tile_data AS tile=>alt_tile BEGIN
		WRITE_SHORT (4 + tilemap_off + 0xa * tile) alt_tile
	END





END


